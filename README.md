# Lustre Sentinel

Lustre Sentinel is a monitoring and auditing tool for Lustre filesystems. It consists of two main components:

- **lsentineld**: A daemon or single-shot tool that consumes Lustre filesystem changelogs from a specified Metadata Target (MDT), processes records (e.g., creates, deletes, renames), resolves file paths using FID-to-path caching, validates UTF-8 safety, and stores audit data (operation type, time, client NID, UID/GID, full path) in a DuckDB database. It supports daemon mode with adaptive polling intervals (1-10 seconds based on activity), consumer registration, and configurable audit masks.
- **sentinel**: A query tool that searches one or more DuckDB databases generated by lsentineld to reconstruct the operation history for a specific file, identified by FID or path. It supports multiple query methods, output formats (text, JSON, YAML, CSV), and handles read-only access to databases, skipping locked ones.

The tool is designed for real-time or batch auditing, with efficient caching (fixed-size in-memory FID cache with 1000 entries and 300-second timeout), fallback path resolution, and lightweight embedded SQL storage via DuckDB. It assumes a Linux environment with Lustre client support and no internet access.

Version: 1.0  
Author: Colin Faber <cfaber@thelustrecollective.com>  
Date: December 28, 2025

## Prerequisites

- **Lustre Client Libraries**: `liblustreapi` (e.g., `lustre-client-devel` on RHEL-based systems or `lustre-dev` on Debian-based systems).
- **DuckDB Library**: `libduckdb` (e.g., `duckdb-devel` or `libduckdb-dev`). If not available via package manager, build from source (see [DuckDB documentation](https://duckdb.org/docs/installation)).
- **C Compiler**: e.g., `gcc`.
- **Build Tools**: Autoconf, Automake, and Libtool.
- **Operating System**: Linux with Lustre filesystem mounted and accessible (e.g., RHEL, Ubuntu, CentOS, Rocky Linux).

### Installing Dependencies

On RHEL-based systems (e.g., CentOS, Rocky Linux):
```bash
sudo yum install lustre-client-devel duckdb-devel gcc autoconf automake libtool
```

On Debian-based systems (e.g., Ubuntu):
```bash
sudo apt-get install lustre-dev libduckdb-dev gcc autoconf automake libtool
```

Note: Package names may vary by distribution and version.

## Building and Installation

The project uses Autoconf and Automake for building. Ensure the project structure includes key files like `configure.ac`, `Makefile.am`, `src/lsentineld.c`, `src/sentinel.c`, etc.

1. **Generate the Configure Script**:
   ```bash
   autoreconf --install
   ```
   This requires Autoconf, Automake, and Libtool.

2. **Configure the Build**:
   ```bash
   ./configure
   ```
   Optional: Specify a custom installation prefix (default: `/usr/local`):
   ```bash
   ./configure --prefix=/usr
   ```

   If dependencies are missing (e.g., `liblustreapi` or `libduckdb`), install them and retry.

3. **Build**:
   ```bash
   make
   ```

4. **Install**:
   ```bash
   sudo make install
   ```

For detailed build instructions, see [BUILD-HOWTO.md](docs/BUILD-HOWTO.md). For design details, see [ABOUT.md](docs/ABOUT.md).

## Usage

### lsentineld (Changelog Consumer)

Run with:
```bash
lsentineld <fsname-MDTnumber> [options]
```

Options:
- `-h`, `--help`: Display help message and exit.
- `-d`, `--daemon`: Run in daemon mode, polling changelog at dynamic intervals (1-10 seconds based on activity level).
- `--consumer <name>`: Specify consumer name (required for running, optional for registration; default: "sentinel").
- `--db <path>`: Path to DuckDB database (required for running and reporting; supports file rotation with templates like "sentinel_%02d.db").
- `--register-consumer`: Register a changelog consumer (requires only MDT; optional mask and name).
- `--audit-mask <full|partial>`: Audit mask for registration (default: partial; "full" includes more events like access times).
- `--report <period>`: Generate report (e.g., daily, weekly; requires --db).
- `-c`, `--config <file>`: Load configuration from file (key=value format; default: /usr/share/sentinel/default.conf).
- `-v`, `--verbose <level>`: Verbosity level (1-10; higher for more details like cache operations).
- `-n`, `--dry-run`: Simulate processing using an in-memory database (no changes committed).
- `--noclear`: Do not clear processed changelogs (useful for testing).

Examples:
- Register consumer: `lsentineld lustre-MDT0000 --register-consumer [--audit-mask full] [--consumer myname]`
- Run daemon: `lsentineld lustre-MDT0000 --db /path/db.duckdb --consumer cl1 --daemon`
- Generate report: `lsentineld --db /path/db.duckdb --report daily`

In daemon mode, handles signals (SIGINT, SIGTERM) for graceful shutdown. Supports database rotation based on time intervals (e.g., via config).

### sentinel (Query Tool)

Query file history with:
```bash
sentinel [options] (--fid <fid> | --path <path>)
```

Options:
- `--db-path <dir>`: Directory to search for databases.
- `--db-template <tmpl>`: Database file template (e.g., "sentinel_%02d.db").
- `--db-glob <glob>`: Glob pattern for database files (e.g., "*.db").
- `--db-files <file1> [<file2>...]`: List of specific database files.
- `--format <text|yaml|json|csv>`: Output format (default: text).
- `--method <attach|loop>`: Query method (default: loop; "attach" for combining databases).
- `-v`, `--verbose`: Increase verbosity (repeat for more).
- `-h`, `--help`: Show help.

Databases are opened read-only; skips locked (active) ones. Outputs history sorted by time, including resolved paths using mount points from `/proc/mounts`.

Examples:
- Query by FID: `sentinel --fid [0x200000007:0x1:0x0] --db-path /path/to/dbs --format json`
- Query by path: `sentinel --path /lustre/file.txt --db-glob "*.db" --verbose`

## Limitations
- Fixed cache size (1000 entries); no resizing.
- Limited to MDT changelogs; no OST support.
- Assumes valid Lustre setup; no retries on API errors.
- Basic reports; extend via DuckDB queries.

For testing, see [TESTING.md](docs/TESTING.md).

## License
GNU General Public License v3 or later (see LICENSE file for details).

### AI-Generated Code Notice

This project incorporates code that was primarily designed and generated with the assistance of Grok, an AI model built by xAI. While Grok aimed to provide efficient and functional solutions based on the provided specifications, AI-generated code can sometimes result in what is colloquially known as "AI slop"â€”overly generic, inefficient, or unoptimized outputs that may lack the nuance of human-crafted code.

Key points to note:
- **Attribution**: The core logic, structure, and implementation details were suggested by Grok in response to iterative prompts.
- **Potential Limitations**: Expect possible redundancies, suboptimal performance, or areas needing refinement. Human review and testing are strongly recommended.
- **Why Use AI?**: It accelerated prototyping and idea exploration, but it's not a substitute for expert engineering.
- **Improvements Welcome**: Feel free to contribute fixes or enhancements via pull requests!

If you're using this code, verify it thoroughly in your environment. For more on Grok, check out [xAI's website](https://x.ai).
