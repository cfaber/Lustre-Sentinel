/*
 * sentinel.c - DuckDB client to query Lustre Sentinel databases for file history
 *
 * This program queries multiple DuckDB databases generated by Lustre Sentinel
 * to construct the operation history for a given file identified by FID or path.
 *
 * Usage: sentinel [options] (--fid <fid> | --path <path>)
 *
 * Options:
 *   --db-path <dir>          Directory to search for databases
 *   --db-template <tmpl>    Database file template (e.g., "sentinel_%02d.db")
 *   --db-glob <glob>        Glob pattern for database files (e.g., "*.db")
 *   --db-files <file1> [<file2>...]  List of database files
 *   --format <text|yaml|json|csv>  Output format (default: text)
 *   --method <attach|loop>  Query method (default: loop)
 *   -v, --verbose           Increase verbosity (repeat for more)
 *   -h, --help              Show this help
 *
 * Databases are opened read-only. If a database is locked (active), it is skipped.
 *
 *
 *
 * Copyright (C) 2025 Colin Faber <cfaber@thelustrecollective.com>
 *
 * This file is part of Lustre Sentinel.
 *
 * Lustre Sentinel is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Lustre Sentinel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Lustre Sentinel.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <duckdb.h>

#include <lustre/lustre_user.h>
#include <lustre/lustreapi.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fnmatch.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include <libgen.h>

#define MAX_PATH 16384
#define MAX_FID_LEN 64
#define MAX_DB_FILES 1024
#define INITIAL_RECORDS_ALLOC 100
#define VERSION		"1.0"

static int verbose = 0;
static char *mount_point = NULL;
#define __MAX(a, b) ((size_t)(a) > (size_t)(b) ? (size_t)(a) : (size_t)(b))
#define __MIN(a, b) ((size_t)(a) < (size_t)(b) ? (size_t)(a) : (size_t)(b))

/*
 * construct_full_path - Construct full path from directory path and name
 * @full_path: Directory path from changelog (e.g., "/cfaber")
 * @name: File or directory name from changelog (e.g., "move")
 * @buf: Buffer to store the constructed full path
 * @buf_len: Size of the buffer
 *
 * Combines full_path and name to form a complete path (e.g., "/cfaber/move").
 * Handles cases where full_path is "/" or empty, and name is empty or NULL.
 * Returns the number of characters written to buf, or -1 on error.
 */
static int construct_full_path(const char *full_path, const char *name, char *buf, size_t buf_len)
{
    if (!buf || buf_len == 0) {
        if (verbose >= 1)
            fprintf(stderr, "Invalid buffer for full path construction\n");
        return -1;
    }

    buf[0] = '\0';

    if (!full_path || !full_path[0]) {
        if (!name || !name[0]) {
            if (verbose >= 4)
                fprintf(stderr, "Both full_path and name are empty, returning empty path\n");
            return 0;
        }
        /* Only name provided, use it directly */
        snprintf(buf, buf_len, "/%s", name);
        if (verbose >= 4)
            fprintf(stderr, "Constructed full path (name only): %s\n", buf);
        return strlen(buf);
    }

    /* Ensure full_path doesn't end with '/' unless it's "/" */
    char clean_path[MAX_PATH];
    strncpy(clean_path, full_path, sizeof(clean_path) - 1);
    clean_path[sizeof(clean_path) - 1] = '\0';
    size_t len = strlen(clean_path);
    if (len > 1 && clean_path[len - 1] == '/')
        clean_path[len - 1] = '\0';

    if (!name || !name[0]) {
        /* Only full_path provided */
        snprintf(buf, buf_len, "%s", clean_path);
        if (verbose >= 4)
            fprintf(stderr, "Constructed full path (path only): %s\n", buf);
        return strlen(buf);
    }

    /* Both full_path and name provided */
    if (strcmp(clean_path, "/") == 0)
        snprintf(buf, buf_len, "/%s", name);
    else
        snprintf(buf, buf_len, "%s/%s", clean_path, name);

    if (verbose >= 4)
        fprintf(stderr, "Constructed full path: %s\n", buf);
    return strlen(buf);
}

/*
 * split_full_path - Split a full path into directory path and filename
 * @full_path: Full path to split (e.g., "/cfaber/move")
 * @dir_path: Buffer to store the directory path (e.g., "/cfaber")
 * @dir_len: Size of the dir_path buffer
 * @filename: Buffer to store the filename (e.g., "move")
 * @file_len: Size of the filename buffer
 *
 * Splits full_path into its directory and filename components.
 * Handles edge cases like root ("/"), empty paths, or trailing slashes.
 * Returns 0 on success, -1 on error (e.g., invalid buffer or insufficient size).
 */
static int split_full_path(const char *full_path, char *dir_path, size_t dir_len,
                           char *filename, size_t file_len)
{
    if (!full_path || !dir_path || !filename || dir_len == 0 || file_len == 0) {
        if (verbose >= 1)
            fprintf(stderr, "Invalid parameters for split_full_path\n");
        return -1;
    }

    dir_path[0] = '\0';
    filename[0] = '\0';

    /* Handle empty or root path */
    if (!full_path[0] || strcmp(full_path, "/") == 0) {
        if (verbose >= 4)
            fprintf(stderr, "Full path is empty or root, setting dir_path=/, filename=\n");
        snprintf(dir_path, dir_len, "/");
        return 0;
    }

    /* Remove trailing slashes */
    char clean_path[MAX_PATH];
    strncpy(clean_path, full_path, sizeof(clean_path) - 1);
    clean_path[sizeof(clean_path) - 1] = '\0';
    size_t len = strlen(clean_path);
    while (len > 1 && clean_path[len - 1] == '/') {
        clean_path[len - 1] = '\0';
        len--;
    }

    /* Find last slash to split path */
    char *last_slash = strrchr(clean_path, '/');
    if (!last_slash) {
        /* No slash, treat as filename in current directory */
        if (verbose >= 4)
            fprintf(stderr, "No slash in path %s, setting dir_path=/, filename=%s\n",
                    clean_path, clean_path);
        snprintf(dir_path, dir_len, "/");
        snprintf(filename, file_len, "%s", clean_path);
        return 0;
    }

    /* Split into directory and filename */
    if (last_slash == clean_path) {
        /* Path is like "/filename" */
        snprintf(dir_path, dir_len, "/");
        snprintf(filename, file_len, "%s", last_slash + 1);
    } else {
        /* Path is like "/dir/subdir/filename" */
        size_t dir_length = last_slash - clean_path;
        if (dir_length >= dir_len) {
            if (verbose >= 1)
                fprintf(stderr, "Directory path too long for buffer: %zu >= %zu\n",
                        dir_length, dir_len);
            return -1;
        }
        strncpy(dir_path, clean_path, dir_length);
        dir_path[dir_length] = '\0';
        snprintf(filename, file_len, "%s", last_slash + 1);
    }

    if (verbose >= 4)
        fprintf(stderr, "Split path %s: dir_path=%s, filename=%s\n",
                clean_path, dir_path, filename);
    return 0;
}

/*
 * llapi_fid2str - Convert Lustre FID to string representation
 * @fid: Pointer to the Lustre FID structure
 * @buf: Buffer to store the string representation
 * @len: Length of the buffer
 *
 * Formats the FID into a string in the format [seq:oid:ver] and stores it in buf.
 * Returns the number of characters written to the buffer.
 */
static int llapi_fid2str(const struct lu_fid *fid, char *buf, int len)
{
        return snprintf(buf, len, "[0x%llx:0x%x:0x%x]", fid->f_seq, fid->f_oid, fid->f_ver);
}

/* is_valid_utf8 - Validate if a string is valid UTF-8
 * @str: String to validate
 *
 * Checks if the input string is a valid UTF-8 encoded string.
 * Returns 1 if valid, 0 otherwise.
 */
int
is_valid_utf8(const char *str)
{
	if (!str)
		return 0;
	for (size_t i = 0; str[i]; i++) {
		if ((str[i] & 0x80) == 0)
			continue;
		else if ((str[i] & 0xE0) == 0xC0) {
			if ((str[++i] & 0xC0) != 0x80)
				return 0;
		} else if ((str[i] & 0xF0) == 0xE0) {
			if ((str[++i] & 0xC0) != 0x80 || (str[++i] & 0xC0) != 0x80)
				return 0;
		} else if ((str[i] & 0xF8) == 0xF0) {
			if ((str[++i] & 0xC0) != 0x80 || (str[++i] & 0xC0) != 0x80 ||
			    (str[++i] & 0xC0) != 0x80)
				return 0;
		} else {
			return 0;
		}
	}
	return 1;
}

/* utf8len - Calculate the length of a UTF-8 string in characters
 * @str: Input string to measure
 *
 * Counts the number of UTF-8 characters (not bytes) in the string.
 * Returns the character count.
 */
size_t
utf8len(const char *str)
{
	size_t len = 0;

	for (size_t i = 0; str[i]; i++) {
		if ((str[i] & 0xC0) != 0x80)
			len++;
	}
	return len;
}

/* utf8_strncpy - Copy a UTF-8 string with boundary checking
 * @dest: Destination buffer
 * @src: Source string
 * @dest_size: Size of the destination buffer
 *
 * Copies the source UTF-8 string to the destination, ensuring proper handling of
 * UTF-8 sequences and null-termination within the destination buffer size.
 */
void
utf8_strncpy(char *dest, const char *src, size_t dest_size)
{
	if (!src || !dest || dest_size == 0)
		return;
	size_t i = 0, j = 0;

	while (src[i] && j < dest_size - 1) {
		dest[j++] = src[i++];
		if ((src[i-1] & 0xC0) == 0xC0 || (src[i-1] & 0xE0) == 0xE0 ||
		    (src[i-1] & 0xF0) == 0xF0) {
			while ((src[i] & 0xC0) == 0x80 && j < dest_size - 1) {
				dest[j++] = src[i++];
			}
		}
	}
	dest[j] = '\0';
	if (!is_valid_utf8(dest))
		dest[0] = '\0';
}

/* sql_escape - Escape single quotes in a string for SQL queries
 * @str: Input string to escape
 * @buf: Output buffer for escaped string
 * @len: Size of the output buffer
 *
 * Escapes single quotes in the input string by doubling them for safe SQL usage.
 */
void
sql_escape(const char *str, char *buf, size_t len)
{
	size_t i = 0, j = 0;

	while (str[i] && j < len - 1) {
		if (str[i] == '\'') {
			if (j < len - 2) {
				buf[j++] = '\'';
				buf[j++] = '\'';
			} else {
				break;
			}
		} else {
			buf[j++] = str[i];
		}
		i++;
	}
	buf[j] = '\0';
}

/* get_full_path - Resolve the full path for a FID
 * @conn: DuckDB connection handle
 * @mount_point: Filesystem mount point
 * @fid: FID to resolve
 * @path: Buffer to store the resolved path
 * @path_len: Size of the path buffer
 * @name_buf: Name from changelog for fallback path construction (optional)
 * @pfid: Parent FID for fallback path construction (optional)
 *
 * Resolves the full path for a FID using parent FID and name, Lustre API, or database lookup.
 * Caches the result and returns 0 on success, negative error code on failure.
 */
int
get_full_path(duckdb_connection conn, const char *mount_point, const char *fid,
              char *path, size_t path_len, const char *name_buf, const char *pfid)
{
    if (verbose >= 7)
        printf("Getting full path for FID %s under mount %s\n", fid, mount_point);

    // Try parent FID and name first if provided
    if (name_buf && name_buf[0] != '\0' && pfid && strncmp(fid, "[0x0:0x0:0x0]", 13) != 0) {
        char parent_path[MAX_PATH];
        int prc = get_full_path(conn, mount_point, pfid, parent_path, sizeof(parent_path), NULL, NULL);
        if (prc == 0 && strncmp(parent_path, "unknown", 7) != 0) {
            size_t parent_len = strnlen(parent_path, MAX_PATH - 1);
            size_t separator_len = (strcmp(parent_path, "/") == 0) ? 0 : 1;
            size_t name_len = strnlen(name_buf, MAX_PATH - parent_len - separator_len - 1);
            size_t total_len = parent_len + separator_len + name_len + 1;

            if (total_len <= MAX_PATH) {
                snprintf(path, path_len, "%s%s%s",
                         parent_path, (strcmp(parent_path, "/") == 0 ? "" : "/"), name_buf);
                path[path_len - 1] = '\0';
                if (verbose >= 5)
                    printf("Constructed path for FID %s: %s\n", fid, path);
                return 0;
            }
        }
    }

    // Fallback to llapi_fid2path
    int rc;
    long long recno = -1;
    int linkno = 0;

    rc = llapi_fid2path(mount_point, fid, path, path_len, &recno, &linkno);
    if (verbose >= 7)
        printf("Calling llapi_fid2path: mount_point=%s, fid=%s, path_len=%zu, recno=%lld, linkno=%d, rc=%d\n",
               mount_point, fid, path_len, recno, linkno, rc);

    if (rc < 0) {
        if (verbose >= 2)
            fprintf(stderr, "Error getting path for FID %s from filesystem: %d (%s)\n",
                    fid, rc, strerror(-rc));

        // Retry once after a short delay
        if (strncmp(fid, "[0x0:0x0:0x0]", 13) != 0) {
            if (verbose >= 2)
                fprintf(stderr, "Retrying llapi_fid2path for FID %s\n", fid);
            sleep(1);
            rc = llapi_fid2path(mount_point, fid, path, path_len, &recno, &linkno);
            if (rc == 0) {
                if (verbose >= 5)
                    printf("Retry succeeded for FID %s: %s\n", fid, path);
                return 0;
            }
        }
    }

    if (rc == 0) {
        // Normalize to absolute path with leading '/'
        char temp[MAX_PATH];
        strncpy(temp, path, sizeof(temp) - 1);
        temp[sizeof(temp) - 1] = '\0';
        if (strcmp(temp, ".") == 0) {
            strcpy(path, "/");
        } else if (temp[0] != '/') {
            size_t temp_len = strlen(temp);
            if (temp_len < path_len - 1) {
                // Enough space: full copy
                path[0] = '/';
                memcpy(path + 1, temp, temp_len);
                path[1 + temp_len] = '\0';
            } else {
                // Truncate to fit (rare case)
                path[0] = '/';
                memcpy(path + 1, temp, path_len - 2);
                path[path_len - 1] = '\0';
            }
        }
    
        if (verbose >= 5)
            printf("Fetched path via API: %s\n", path);
    
        return 0;
    }
    
    // Fallback to DB lookup as last resort
    char escaped_fid[128];
    sql_escape(fid, escaped_fid, sizeof(escaped_fid));
    char query[256];
    snprintf(query, sizeof(query), "SELECT current_path FROM files WHERE fid = '%s'", escaped_fid);
    if (verbose >= 3)
        printf("Executing SQL for path fallback: %s\n", query);
    duckdb_result result;

    if (duckdb_query(conn, query, &result) == DuckDBSuccess) {
        if (duckdb_row_count(&result) > 0) {
            char *db_path = duckdb_value_varchar(&result, 0, 0);
            if (db_path && db_path[0] != '\0' && strcmp(db_path, "unknown (invalid FID)") != 0) {
                utf8_strncpy(path, db_path, path_len);
                if (verbose >= 5)
                    printf("Fetched path via DB: %s\n", path);
                duckdb_destroy_result(&result);
                duckdb_free(db_path);
                return 0;
            }
            duckdb_free(db_path);
        }
        duckdb_destroy_result(&result);
    } else {
        const char *err = duckdb_result_error(&result);
        if (verbose >= 1)
            fprintf(stderr, "Error querying DB for FID %s: %s\n", fid, err ? err : "unknown");
        duckdb_destroy_result(&result);
    }

    // Set unknown if all else fails
    strncpy(path, "unknown (invalid FID)", path_len - 1);
    path[path_len - 1] = '\0';
    return rc;
}

/*
 * get_current_path - Resolve the current full path for a FID using Lustre API
 * @mount_point: Filesystem mount point
 * @fid: FID string to resolve
 * @path: Buffer to store the resolved path
 * @path_len: Size of the path buffer
 *
 * Uses llapi_fid2path to get the current path. Returns 0 on success,
 * negative error code on failure (e.g., -ENOENT if file does not exist).
 */
static int get_current_path(const char *mount_point, const char *fid,
                            char *path, size_t path_len)
{
        long long recno = -1;
        int linkno = 0;
        int rc;

        if (verbose >= 5)
                fprintf(stderr, "Resolving current path for FID %s at mount %s\n",
                        fid, mount_point);

        rc = llapi_fid2path(mount_point, fid, path, path_len, &recno, &linkno);
        if (rc < 0) {
                if (verbose >= 2)
                        fprintf(stderr, "llapi_fid2path failed for FID %s: %s\n",
                                fid, strerror(-rc));

                return rc;
        }

        if (path[0] != '/') {
                memmove(path + 1, path, strlen(path) + 1);
                path[0] = '/';
        }

        if (verbose >= 6)
                fprintf(stderr, "Resolved path: %s\n", path);
        return 0;
}

/*
 * get_parent_fid_from_path - Get the FID of the parent directory from a path
 * @mount_point: Filesystem mount point
 * @full_path: Full path to the file
 * @parent_fid: Buffer to store the parent FID string
 * @fid_len: Size of the parent_fid buffer
 *
 * Extracts dirname from full_path, resolves its FID using llapi_path2fid.
 * Returns 0 on success, negative error code on failure.
 */
static int get_parent_fid_from_path(const char *mount_point, const char *full_path,
                                    char *parent_fid, size_t fid_len)
{
    char dir_path[MAX_PATH];
    char full_dir_path[MAX_PATH];
    struct lu_fid fid;
    int rc;

    if (!mount_point || !mount_point[0]) {
        if (verbose >= 2)
            fprintf(stderr, "Mount point is required for path-to-FID resolution\n");
        return -EINVAL;
    }

    strncpy(dir_path, full_path, sizeof(dir_path) - 1);
    dir_path[sizeof(dir_path) - 1] = '\0';
    char *slash = strrchr(dir_path, '/');
    if (slash && slash != dir_path)
        *slash = '\0';
    else
        strcpy(dir_path, "/");

    // Construct full system path: mount_point + dir_path
    snprintf(full_dir_path, sizeof(full_dir_path), "%s%s", mount_point, dir_path);

    if (verbose >= 5)
        fprintf(stderr, "Resolving parent FID for full path %s\n", full_dir_path);

    rc = llapi_path2fid(full_dir_path, &fid);
    if (rc < 0) {
        if (verbose >= 2)
            fprintf(stderr, "llapi_path2fid failed for %s: %s\n",
                    full_dir_path, strerror(-rc));
        return rc;
    }

    llapi_fid2str(&fid, parent_fid, fid_len);
    if (verbose >= 6)
        fprintf(stderr, "Parent FID: %s\n", parent_fid);
    return 0;
}

/*
 * basename_safe - Get basename of a path (safe copy)
 * @path: Input path
 *
 * Returns a static buffer with the basename. Handles edge cases like "/".
 */
static const char *basename_safe(const char *path)
{
        static char buf[MAX_PATH];
        const char *base = strrchr(path, '/');

        if (base)
                strncpy(buf, base + 1, sizeof(buf) - 1);
        else
                strncpy(buf, path, sizeof(buf) - 1);
        buf[sizeof(buf) - 1] = '\0';
        return buf;
}

/*
 * dirname_safe - Get dirname of a path (safe copy)
 * @path: Input path
 *
 * Returns a static buffer with the dirname. Handles edge cases.
 */
static const char *dirname_safe(const char *path)
{
    static char buf[MAX_PATH];
    strncpy(buf, path, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = '\0';
    char *slash = strrchr(buf, '/');
    if (slash && slash != buf)
        *slash = '\0';
    else
        strcpy(buf, "/");
    return buf;
}

struct history_record {
	long long id;
	char *op_type;
	char *op_time;
	int flags;
	char *tfid;
	char *pfid;
	char *name;
	char *uid;
	char *gid;
	char *client_nid;
	char *job_id;
	char *full_path;
};

struct history_list {
	struct history_record **records;
	size_t count;
	size_t alloc;
};

/* Translate short operation type to full description */
static const char *translate_op_type(const char *op_type)
{
        if (!op_type)
                return "";
        if (strcmp(op_type, "CREAT") == 0)
                return "File Created";
        if (strcmp(op_type, "OPEN") == 0)
                return "File Opened";
        if (strcmp(op_type, "UNLNK") == 0)
                return "File Unlinked";
        if (strcmp(op_type, "MKDIR") == 0)
                return "Directory Created";
        if (strcmp(op_type, "RMDIR") == 0)
                return "Directory Removed";
        if (strcmp(op_type, "RENME") == 0)
                return "File Renamed";
        if (strcmp(op_type, "WRITE") == 0)
                return "File Written";
        if (strcmp(op_type, "READ") == 0)
                return "File Read";
        if (strcmp(op_type, "TRUNC") == 0)
                return "File Truncated";
        if (strcmp(op_type, "SLINK") == 0)
                return "Symbolic Link Created";
        if (strcmp(op_type, "MKNOD") == 0)
                return "Special File Created";
        if (strcmp(op_type, "SETATTR") == 0)
                return "Attributes Set";
        if (strcmp(op_type, "XATTR") == 0)
                return "Extended Attributes Modified";
        if (strcmp(op_type, "HARDLINK") == 0)
                return "Hard Link Created";
        if (strcmp(op_type, "IOCTL") == 0)
                return "IO Control Operation";
        if (strcmp(op_type, "CLOSE") == 0)
                return "File Closed";
        if (strcmp(op_type, "SATTR") == 0)
                return "Security Attributes Set";
        if (strcmp(op_type, "MKQUOTA") == 0)
                return "Quota Created";
        if (strcmp(op_type, "RMQUOTA") == 0)
                return "Quota Removed";
        return op_type; /* Return original if unknown */
}

static void free_record(struct history_record *rec)
{
	if (!rec)
		return;
	if (verbose >= 8)
		fprintf(stderr, "Freeing record with id %lld\n", rec->id);
	duckdb_free(rec->op_type);
	duckdb_free(rec->op_time);
	duckdb_free(rec->tfid);
	duckdb_free(rec->pfid);
	duckdb_free(rec->name);
	duckdb_free(rec->uid);
	duckdb_free(rec->gid);
	duckdb_free(rec->client_nid);
	duckdb_free(rec->job_id);
	duckdb_free(rec->full_path);
	free(rec);
}

static void free_history_list(struct history_list *list)
{
	if (!list)
		return;
	if (verbose >= 5)
		fprintf(stderr, "Freeing history list with %zu records\n", list->count);
	for (size_t i = 0; i < list->count; i++)
		free_record(list->records[i]);
	free(list->records);
	free(list);
}

static int add_record(struct history_list *list, struct history_record *rec)
{
	if (verbose >= 7)
		fprintf(stderr, "Adding record id %lld to history list\n", rec->id);
	if (list->count >= list->alloc) {
		size_t new_alloc = list->alloc * 2;
		if (new_alloc == 0)
			new_alloc = INITIAL_RECORDS_ALLOC;
		if (verbose >= 8)
			fprintf(stderr, "Reallocating history list from %zu to %zu\n",
				list->alloc, new_alloc);
		struct history_record **new_records =
			realloc(list->records,
				new_alloc * sizeof(struct history_record *));
		if (!new_records) {
			if (verbose >= 1)
				fprintf(stderr, "Failed to reallocate history list\n");
			return -ENOMEM;
		}
		list->records = new_records;
		list->alloc = new_alloc;
	}
	list->records[list->count++] = rec;
	return 0;
}

static int cmp_records(const void *a, const void *b)
{
	const struct history_record *ra = *(const struct history_record **)a;
	const struct history_record *rb = *(const struct history_record **)b;
	if (verbose >= 9)
		fprintf(stderr, "Comparing records id %lld vs %lld\n",
			ra->id, rb->id);
	if (ra->id < rb->id)
		return -1;
	if (ra->id > rb->id)
		return 1;
	return 0;
}

static void sort_history_list(struct history_list *list)
{
	if (verbose >= 5)
		fprintf(stderr, "Sorting history list with %zu records\n", list->count);
	qsort(list->records, list->count, sizeof(struct history_record *),
	      cmp_records);
}

static struct history_record *extract_record(duckdb_result *result,
					     idx_t row)
{
	struct history_record *rec = calloc(1, sizeof(*rec));
	if (!rec) {
		if (verbose >= 1)
			fprintf(stderr, "Failed to allocate history record\n");
		return NULL;
	}

	rec->id = duckdb_value_int64(result, 0, row);
	rec->op_type = duckdb_value_varchar(result, 1, row);
	rec->op_time = duckdb_value_varchar(result, 2, row);
	rec->flags = duckdb_value_int32(result, 3, row);
	rec->tfid = duckdb_value_varchar(result, 4, row);
	rec->pfid = duckdb_value_varchar(result, 5, row);
	rec->name = duckdb_value_varchar(result, 6, row);
	rec->uid = duckdb_value_varchar(result, 7, row);
	rec->gid = duckdb_value_varchar(result, 8, row);
	rec->client_nid = duckdb_value_varchar(result, 9, row);
	rec->job_id = duckdb_value_varchar(result, 10, row);
	rec->full_path = duckdb_value_varchar(result, 11, row);

	if (verbose >= 6)
		fprintf(stderr, "Extracted record id %lld: type=%s, time=%s, path=%s\n",
			rec->id,
			rec->op_type ? rec->op_type : "(null)",
			rec->op_time ? rec->op_time : "(null)",
			rec->full_path ? rec->full_path : "(null)");
	return rec;
}

static void normalize_fid(char *fid)
{
	if (!fid)
		return;
	for (char *p = fid; *p; p++)
		*p = tolower(*p);
}

/*
 * collect_db_files - Collect database files based on path, template, or glob
 * @db_path: Directory to search for databases
 * @db_template: Database file template (e.g., "sentinel_%02d.db")
 * @db_glob: Glob pattern for database files (e.g., "*.db")
 * @db_files_list: Explicit list of database files
 * @db_files_count: Number of files in db_files_list
 * @db_files: Output array of collected file paths
 * @db_files_total: Output number of collected files
 *
 * Collects database files from db_path matching db_glob or db_template,
 * or uses db_files_list. Normalizes db_path and logs detailed reasons for skipping files.
 * Uses *.db as default glob if none provided.
 * Returns 0 on success, negative error code on failure.
 */
static int collect_db_files(const char *db_path, const char *db_template,
                            const char *db_glob, char **db_files_list,
                            int db_files_count, char ***db_files,
                            int *db_files_total)
{
    char **files = NULL;
    int count = 0;
    struct dirent *de;
    DIR *dir = NULL;
    char normalized_path[MAX_PATH];
    char search_path[MAX_PATH];
    char glob_pattern[MAX_PATH] = {0};
    bool using_glob = false;
    bool using_template = false;
    const char *effective_glob = db_glob ? db_glob : "*.db";

    /* Normalize db_path by removing trailing '/.' or '/' */
    if (db_path) {
        strncpy(normalized_path, db_path, sizeof(normalized_path) - 1);
        normalized_path[sizeof(normalized_path) - 1] = '\0';
        size_t len = strlen(normalized_path);
        if (len > 1 && strcmp(normalized_path + len - 2, "/.") == 0)
            normalized_path[len - 2] = '\0';
        else if (len > 1 && normalized_path[len - 1] == '/')
            normalized_path[len - 1] = '\0';
    } else {
        strcpy(normalized_path, ".");
    }

    /* Handle glob: extract directory and pattern if db_glob contains a path */
    if (db_glob && strlen(db_glob) > 0 && (strchr(db_glob, '*') || strchr(db_glob, '?'))) {
        char glob_copy[MAX_PATH];
        strncpy(glob_copy, db_glob, sizeof(glob_copy) - 1);
        glob_copy[sizeof(glob_copy) - 1] = '\0';
        char *dir = dirname(glob_copy);
        char base_copy[MAX_PATH];
        strncpy(base_copy, db_glob, sizeof(base_copy) - 1);
        base_copy[sizeof(base_copy) - 1] = '\0';
        char *pattern = basename(base_copy);
    
        if (strchr(db_glob, '/') != NULL) {
            // db_glob includes a path (e.g., "/tmp/*.db"); validate and use the extracted dir
            struct stat st;
            if (stat(dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
                if (verbose >= 1)
                    fprintf(stderr, "Invalid directory for glob pattern: %s\n", dir);
                return -ENOENT;
            }
            strncpy(search_path, dir, sizeof(search_path) - 1);
            search_path[sizeof(search_path) - 1] = '\0';
            size_t search_len = strlen(search_path);
            if (search_len > 1 && search_path[search_len - 1] == '/')
                search_path[search_len - 1] = '\0';
        } else {
            // db_glob is a standalone pattern (e.g., "*.db"); use normalized_path (db_path) as dir
            strncpy(search_path, normalized_path, sizeof(search_path) - 1);
            search_path[sizeof(search_path) - 1] = '\0';
        }
    
        strncpy(glob_pattern, pattern, sizeof(glob_pattern) - 1);
        glob_pattern[sizeof(glob_pattern) - 1] = '\0';
        effective_glob = glob_pattern;
        using_glob = true;
        if (verbose >= 3)
            fprintf(stderr, "Extracted from glob: search_dir=%s, pattern=%s\n",
                    search_path, glob_pattern);
    } else {
        strncpy(search_path, normalized_path, sizeof(search_path) - 1);
        search_path[sizeof(search_path) - 1] = '\0';
    }
    
    /* Handle template: extract directory and pattern if db_template is a full path */
    char template_pattern[MAX_PATH] = {0};
    if (db_template && strlen(db_template) > 0) {
        char dir_copy[MAX_PATH];
        strncpy(dir_copy, db_template, sizeof(dir_copy) - 1);
        dir_copy[sizeof(dir_copy) - 1] = '\0';
        char *dir = dirname(dir_copy);
        char base_copy[MAX_PATH];
        strncpy(base_copy, db_template, sizeof(base_copy) - 1);
        base_copy[sizeof(base_copy) - 1] = '\0';
        char *pattern = basename(base_copy);
    
        if (strchr(db_template, '/') != NULL) {
            // db_template includes a path (e.g., "/tmp/sentinel_%02d.db"); validate and use the extracted dir
            struct stat st;
            if (stat(dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
                if (verbose >= 1)
                    fprintf(stderr, "Invalid directory for template pattern: %s\n", dir);
                return -EINVAL;
            }
            strncpy(search_path, dir, sizeof(search_path) - 1);
            search_path[sizeof(search_path) - 1] = '\0';
            size_t search_len = strlen(search_path);
            if (search_len > 1 && search_path[search_len - 1] == '/')
                search_path[search_len - 1] = '\0';
        } else {
            // db_template is a standalone pattern (e.g., "sentinel_%02d.db"); use normalized_path (db_path) as dir
            strncpy(search_path, normalized_path, sizeof(search_path) - 1);
            search_path[sizeof(search_path) - 1] = '\0';
        }
    
        strncpy(template_pattern, pattern, sizeof(template_pattern) - 1);
        template_pattern[sizeof(template_pattern) - 1] = '\0';
        using_template = true;
        if (verbose >= 3)
            fprintf(stderr, "Extracted from template: search_dir=%s, pattern=%s\n",
                    search_path, template_pattern);
    }
    
    /* Prefer template's search_path if both are provided (now respects db_path if no path in patterns) */
    char *effective_search_dir = search_path;
    
    if (verbose >= 2)
        fprintf(stderr, "Collecting database files: dir=%s, template=%s, glob=%s, file_count=%d\n",
                effective_search_dir, db_template ? db_template : "(null)",
                effective_glob, db_files_count);

    if (db_files_list && db_files_count > 0) {
        if (verbose >= 2)
            fprintf(stderr, "Using %d provided database files\n", db_files_count);
        files = malloc(db_files_count * sizeof(char *));
        if (!files) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to allocate memory for db files\n");
            return -ENOMEM;
        }
        for (int i = 0; i < db_files_count; i++) {
            files[i] = strdup(db_files_list[i]);
            if (!files[i]) {
                if (verbose >= 1)
                    fprintf(stderr, "Failed to duplicate file path %s\n",
                            db_files_list[i]);
                for (int j = 0; j < i; j++)
                    free(files[j]);
                free(files);
                return -ENOMEM;
            }
            if (verbose >= 4)
                fprintf(stderr, "Added file: %s\n", files[i]);
        }
        count = db_files_count;
        goto done;
    }

    if (verbose >= 2)
        fprintf(stderr, "Opening directory: %s\n", effective_search_dir);
    dir = opendir(effective_search_dir);
    if (!dir) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to open directory %s: %s\n",
                    effective_search_dir, strerror(errno));
        return -errno;
    }

    while ((de = readdir(dir)) != NULL) {
        if (verbose >= 4)
            fprintf(stderr, "Examining file: %s (type=%d)\n",
                    de->d_name, de->d_type);
        if (de->d_type != DT_REG && de->d_type != DT_UNKNOWN) {
            if (verbose >= 4)
                fprintf(stderr, "Skipping %s: not a regular file (type=%d)\n",
                        de->d_name, de->d_type);
            continue;
        }

        bool matches_glob = false; // Default to false to be stricter
        if (using_glob) {
            if (fnmatch(effective_glob, de->d_name, 0) == 0) {
                matches_glob = true;
                if (verbose >= 4)
                    fprintf(stderr, "Matched glob %s: file %s\n",
                            effective_glob, de->d_name);
            } else {
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: does not match glob %s\n",
                            de->d_name, effective_glob);
            }
        }
        if (!matches_glob && using_glob) {
            continue;
        }

        bool matches_template = true;

        if (using_template) {
            char prefix[PATH_MAX] = {0};
            char suffix[PATH_MAX] = {0};
            char specifier[16] = {0}; // Store the full specifier (e.g., "%03d", "%ld")
            char type_str[8] = {0};   // Store type (e.g., "d", "ld")
            int width = 0;            // Width of the specifier (e.g., 3 for %03d)
            int specifier_len = 0;    // Length of the specifier string
            int seq = 0;              // Parsed sequence number
            bool matches_template = true;
        
            // Copy template for manipulation
            char fmt_copy[PATH_MAX];
            strncpy(fmt_copy, template_pattern, sizeof(fmt_copy) - 1);
            fmt_copy[sizeof(fmt_copy) - 1] = '\0';
        
            // Find and parse the printf-style specifier
            char *percent_pos = strchr(fmt_copy, '%');
            if (percent_pos && percent_pos[1] != '%') { // Ignore %%
                char *spec_end = percent_pos + 1;
                // Skip flags (e.g., +, -, 0, space)
                while (*spec_end && strchr("+-0 #", *spec_end)) {
                    spec_end++;
                }
                // Parse width (if any)
                if (isdigit((unsigned char)*spec_end)) {
                    char width_str[16] = {0};
                    char *num_start = spec_end;
                    while (isdigit((unsigned char)*spec_end)) {
                        spec_end++;
                    }
                    strncpy(width_str, num_start, spec_end - num_start);
                    width_str[spec_end - num_start] = '\0';
                    width = atoi(width_str);
                }
                // Get specifier type (e.g., "d", "ld")
                if (*spec_end == 'd') {
                    strcpy(type_str, "d");
                    specifier_len = spec_end - percent_pos + 1;
                } else if (*spec_end == 'l' && *(spec_end + 1) == 'd') {
                    strcpy(type_str, "ld");
                    spec_end++;
                    specifier_len = spec_end - percent_pos + 1;
                } else {
                    // Unsupported specifier type
                    matches_template = false;
                    if (verbose >= 4)
                        fprintf(stderr, "Template %s has unsupported specifier type at '%c'\n",
                                template_pattern, *spec_end);
                    continue;
                }
                // Copy full specifier for logging
                strncpy(specifier, percent_pos, specifier_len);
                specifier[specifier_len] = '\0';
            } else {
                // No specifier or only %%: treat as literal match
                if (strcmp(de->d_name, template_pattern) != 0) {
                    matches_template = false;
                    if (verbose >= 4)
                        fprintf(stderr, "Skipping %s: does not match literal template %s\n",
                                de->d_name, template_pattern);
                    continue;
                }
                matches_template = true;
                if (verbose >= 4)
                    fprintf(stderr, "Matched literal template %s for file %s\n",
                            template_pattern, de->d_name);
                continue; // Literal match succeeded
            }
        
            // Extract prefix and suffix
            size_t pre_len = percent_pos - fmt_copy;
            strncpy(prefix, fmt_copy, pre_len);
            prefix[pre_len] = '\0';
            strcpy(suffix, percent_pos + specifier_len);
        
            // Match filename: prefix + digits + suffix
            size_t prefix_len = strlen(prefix);
            if (strncmp(de->d_name, prefix, prefix_len) != 0) {
                matches_template = false;
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: prefix '%s' does not match\n",
                            de->d_name, prefix);
                continue;
            }
        
            const char *after_prefix = de->d_name + prefix_len;
            const char *num_end = after_prefix;
            while (isdigit((unsigned char)*num_end)) {
                num_end++;
            }
            size_t num_len = num_end - after_prefix;
        
            if (num_len == 0) {
                matches_template = false;
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: no digits found after prefix '%s'\n",
                            de->d_name, prefix);
                continue;
            }
        
            // Optional: Enforce width if specified (e.g., %03d requires exactly 3 digits)
            if (width > 0 && num_len != (size_t)width) {
                matches_template = false;
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: number digits (%zu) do not match width %d\n",
                            de->d_name, num_len, width);
                continue;
            }
        
            // Check suffix
            if (strcmp(num_end, suffix) != 0) {
                matches_template = false;
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: suffix '%s' does not match expected '%s'\n",
                            de->d_name, num_end, suffix);
                continue;
            }
        
            // Parse the sequence number
            char num_str[32];
            strncpy(num_str, after_prefix, num_len);
            num_str[num_len] = '\0';
            seq = atoi(num_str); // Works for %d, %ld (int or long parsed as int here)
            if (seq < 0) {
                matches_template = false;
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: invalid sequence number %d\n",
                            de->d_name, seq);
                continue;
            }
        
            // Use matches_template to decide whether to process the file
            if (!matches_template) {
                if (verbose >= 4)
                    fprintf(stderr, "Skipping %s: does not match template %s\n",
                            de->d_name, template_pattern);
                continue;
            }
        
            if (verbose >= 4)
                fprintf(stderr, "Matched template %s: seq=%d for file %s (prefix='%s', num='%s', suffix='%s')\n",
                        template_pattern, seq, de->d_name, prefix, num_str, suffix);
        }

	if ((using_glob && !matches_glob) || (using_template && !matches_template)) {
	    continue;
	}

        char full_path[MAX_PATH];
        snprintf(full_path, sizeof(full_path), "%s/%s", effective_search_dir, de->d_name);
        if (verbose >= 4)
            fprintf(stderr, "Checking access to %s\n", full_path);
        if (access(full_path, R_OK) != 0) {
            if (verbose >= 4)
                fprintf(stderr, "Skipping %s: not readable (%s)\n",
                        full_path, strerror(errno));
            continue;
        }

        char **new_files = realloc(files, (count + 1) * sizeof(char *));
        if (!new_files) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to allocate memory for file list\n");
            closedir(dir);
            for (int i = 0; i < count; i++)
                free(files[i]);
            free(files);
            return -ENOMEM;
        }
        files = new_files;
        files[count] = strdup(full_path);
        if (!files[count]) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to duplicate path %s\n", full_path);
            closedir(dir);
            for (int i = 0; i < count; i++)
                free(files[i]);
            free(files);
            return -ENOMEM;
        }
        if (verbose >= 4)
            fprintf(stderr, "Added file: %s\n", files[count]);
        count++;
    }
    closedir(dir);

done:
    *db_files = files;
    *db_files_total = count;
    if (verbose >= 2)
        fprintf(stderr, "Collected %d database files\n", count);
    return 0;
}

/*
 * find_latest_db - Collect and sort database files by modification time
 * @db_files: Array of database file paths
 * @db_files_total: Number of database files
 * @sorted_db_files: Pointer to store the sorted array of database file paths
 * @sorted_db_files_total: Pointer to store the number of sorted database files
 *
 * Scans the database files, retrieves their modification times using stat, and
 * sorts them in descending order of modification time (newest first). Allocates
 * a new array to store the sorted file paths. The caller is responsible for
 * freeing the sorted array. Returns 0 on success, negative error code on failure
 * (-ENOENT if no valid files, -ENOMEM for memory allocation failures).
 */
static int find_latest_db(char **db_files, int db_files_total,
                         char ***sorted_db_files, int *sorted_db_files_total)
{
    struct db_entry {
        char *path;
        time_t mtime;
    };
    struct db_entry *entries = NULL;

    if (verbose >= 4)
        fprintf(stderr, "Finding and sorting %d database files\n", db_files_total);

    entries = calloc(db_files_total, sizeof(struct db_entry));
    if (!entries) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to allocate memory for database entries\n");
        return -ENOMEM;
    }

    int valid_count = 0;
    for (int i = 0; i < db_files_total; i++) {
        struct stat st;
        if (stat(db_files[i], &st) != 0) {
            if (verbose >= 2)
                fprintf(stderr, "Failed to stat %s: %s\n", db_files[i], strerror(errno));
            continue;
        }
        entries[valid_count].path = db_files[i];
        entries[valid_count].mtime = st.st_mtime;
        if (verbose >= 5)
            fprintf(stderr, "Database %s has mtime %ld\n", db_files[i], st.st_mtime);
        valid_count++;
    }

    if (valid_count == 0) {
        if (verbose >= 1)
            fprintf(stderr, "No valid database files found\n");
        free(entries);
        return -ENOENT;
    }

    /* Sort by mtime (descending) */
    for (int i = 0; i < valid_count - 1; i++) {
        for (int j = i + 1; j < valid_count; j++) {
            if (entries[i].mtime < entries[j].mtime) {
                struct db_entry temp = entries[i];
                entries[i] = entries[j];
                entries[j] = temp;
            }
        }
    }

    /* Allocate sorted array */
    char **sorted = malloc(valid_count * sizeof(char *));
    if (!sorted) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to allocate memory for sorted database list\n");
        free(entries);
        return -ENOMEM;
    }

    for (int i = 0; i < valid_count; i++) {
        sorted[i] = strdup(entries[i].path);
        if (!sorted[i]) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to duplicate path %s\n", entries[i].path);
            for (int j = 0; j < i; j++)
                free(sorted[j]);
            free(sorted);
            free(entries);
            return -ENOMEM;
        }
    }

    *sorted_db_files = sorted;
    *sorted_db_files_total = valid_count;
    free(entries);

    if (verbose >= 3)
        fprintf(stderr, "Sorted %d database files, newest: %s\n", valid_count, sorted[0]);
    return 0;
}


/*
 * resolve_path_to_fid - Resolve a file path to its Lustre FID using Lustre API and database
 * @path: Input path (relative, absolute with/without mount point)
 * @db_files: Array of database file paths
 * @db_files_total: Number of database files
 * @fid: Buffer to store the resolved FID string
 * @fid_len: Size of the fid buffer
 * @mount_point: The mount point to lustre
 *
 * Normalizes the input path by stripping the mount point (replacing it with an empty string)
 * to match the database's path format, attempts llapi_path2fid with the mount point re-added,
 * and falls back to querying database files (newest first) using the changelog table's full_path
 * and name fields. Uses split_full_path to separate directory and filename for querying.
 * Returns 0 on success, negative error code on failure (-ENOENT if path not found,
 * -EIO for database errors, -ENOMEM for memory allocation failures).
 */
static int resolve_path_to_fid(const char *path, char **db_files,
                               int db_files_total, char *fid, size_t fid_len,
                               const char *mount_point)
{
    if (!path || !fid || fid_len == 0) {
        if (verbose >= 1)
            fprintf(stderr, "Invalid input parameters for path-to-FID resolution\n");
        return -EINVAL;
    }

    if (verbose >= 3)
        fprintf(stderr, "Resolving path %s to FID, mount_point: %s\n", path, mount_point ? mount_point : "(null)");

    /* Normalize path: strip mount_point if present, ensure correct format */
    char normalized_path[MAX_PATH];
    char resolved_path[MAX_PATH];
    const char *effective_path = path;

    /* Resolve relative path to absolute if necessary */
    if (path[0] != '/') {
        if (realpath(path, resolved_path) == NULL) {
            if (verbose >= 2)
                fprintf(stderr, "Failed to resolve relative path %s: %s, using as-is\n", path, strerror(errno));
            /* Use original path if resolution fails (e.g., file doesn't exist) */
            strncpy(resolved_path, path, sizeof(resolved_path) - 1);
            resolved_path[sizeof(resolved_path) - 1] = '\0';
        }
        effective_path = resolved_path;
        if (verbose >= 4)
            fprintf(stderr, "Resolved relative path to: %s\n", effective_path);
    }

    /* Strip mount_point from the beginning of the path, replacing with empty string */
    strncpy(normalized_path, effective_path, sizeof(normalized_path) - 1);
    normalized_path[sizeof(normalized_path) - 1] = '\0';
    if (mount_point && strlen(mount_point) > 0 && strncmp(effective_path, mount_point, strlen(mount_point)) == 0) {
        const char *relative_path = effective_path + strlen(mount_point);
        if (*relative_path == '\0') {
            strcpy(normalized_path, "");
        } else {
            /* Ensure path starts with '/' */
            char temp_path[MAX_PATH];
            if (*relative_path == '/') {
                strncpy(temp_path, relative_path, sizeof(temp_path) - 1);
            } else {
                snprintf(temp_path, sizeof(temp_path), "/%s", relative_path);
            }
            temp_path[sizeof(temp_path) - 1] = '\0';
            strncpy(normalized_path, temp_path, sizeof(normalized_path) - 1);

            normalized_path[sizeof(normalized_path) - 1] = '\0';
        }
        if (verbose >= 4)
            fprintf(stderr, "Stripped mount_point %s from %s, normalized path: %s\n", mount_point, effective_path, normalized_path);
    } else {
        if (verbose >= 4)
            fprintf(stderr, "No mount_point to strip or mount_point is NULL, using path: %s\n", normalized_path);
    }

    /* Attempt llapi_path2fid if mount_point is provided */
    if (mount_point && strlen(mount_point) > 0) {
        char full_path[MAX_PATH];
        struct lu_fid lu_fid;
        int rc;

        /* Construct full path with mount_point for llapi_path2fid */
        if (normalized_path[0] == '\0') {
            snprintf(full_path, sizeof(full_path), "%s", mount_point);
        } else {
            /* Ensure mount_point ends with '/' to avoid double slashes */
            char mount_with_slash[MAX_PATH];
            strncpy(mount_with_slash, mount_point, sizeof(mount_with_slash) - 2);
            mount_with_slash[sizeof(mount_with_slash) - 2] = '\0';
            if (mount_with_slash[strlen(mount_with_slash) - 1] != '/') {
                strcat(mount_with_slash, "/");
            }
            snprintf(full_path, sizeof(full_path), "%s%s", mount_with_slash, normalized_path);
        }
        if (verbose >= 4)
            fprintf(stderr, "Attempting llapi_path2fid on full path: %s\n", full_path);

        rc = llapi_path2fid(full_path, &lu_fid);
        if (rc == 0) {
            rc = llapi_fid2str(&lu_fid, fid, fid_len);
            if (rc >= 0) {
                normalize_fid(fid);
                if (verbose >= 3)
                    fprintf(stderr, "Resolved FID via llapi_path2fid: %s for path %s\n", fid, full_path);
                return 0;
            } else {
                if (verbose >= 2)
                    fprintf(stderr, "Failed to format FID for path %s: %s\n", full_path, strerror(-rc));
            }
        } else {
            if (verbose >= 2)
                fprintf(stderr, "llapi_path2fid failed for path %s: %s\n", full_path, strerror(-rc));
        }
    } else {
        if (verbose >= 2)
            fprintf(stderr, "Skipping llapi_path2fid: no mount point provided\n");
    }

    /* Get sorted list of databases (newest first) */
    char **sorted_db_files = NULL;
    int sorted_db_files_total = 0;
    int rc = find_latest_db(db_files, db_files_total, &sorted_db_files, &sorted_db_files_total);
    if (rc < 0) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to sort database files: %s\n", strerror(-rc));
        return rc;
    }

    if (sorted_db_files_total == 0) {
        if (verbose >= 1)
            fprintf(stderr, "No database files available for path resolution\n");
        for (int j = 0; j < sorted_db_files_total; j++)
            free(sorted_db_files[j]);
        free(sorted_db_files);
        return -ENOENT;
    }

    /* Split normalized_path into directory and filename */
    char dir_path[MAX_PATH];
    char filename[MAX_PATH];
    if (normalized_path[0] == '\0') {
        strcpy(dir_path, "/");
        filename[0] = '\0';
    } else {
        if (split_full_path(normalized_path, dir_path, sizeof(dir_path), filename, sizeof(filename)) < 0) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to split path %s\n", normalized_path);
            for (int j = 0; j < sorted_db_files_total; j++)
                free(sorted_db_files[j]);
            free(sorted_db_files);
            return -EINVAL;
        }
    }
    if (verbose >= 4)
        fprintf(stderr, "Split path %s: dir_path=%s, filename=%s\n", normalized_path, dir_path, filename);

    /* Iterate through databases */
    for (int i = 0; i < sorted_db_files_total; i++) {
        char *db_file = sorted_db_files[i];
        duckdb_database db;
        duckdb_connection conn;
        duckdb_config config;
        duckdb_prepared_statement stmt;
        duckdb_result result;
        char *err = NULL;

        if (verbose >= 4)
            fprintf(stderr, "Creating DuckDB config for read-only access to %s\n", db_file);
        if (duckdb_create_config(&config) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to create DuckDB config for %s\n", db_file);
            continue;
        }
        duckdb_set_config(config, "access_mode", "READ_ONLY");
        if (duckdb_open_ext(db_file, &db, config, &err) != DuckDBSuccess) {
            if (verbose >= 1) {
                if (err && strstr(err, "Could not set lock"))
                    fprintf(stderr, "Database %s is locked, trying next\n", db_file);
                else
                    fprintf(stderr, "Failed to open %s read-only: %s\n", db_file, err ? err : "unknown");
            }
            duckdb_free(err);
            duckdb_destroy_config(&config);
            continue;
        }
        duckdb_destroy_config(&config);

        if (verbose >= 5)
            fprintf(stderr, "Connecting to database %s\n", db_file);
        if (duckdb_connect(db, &conn) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to connect to database %s\n", db_file);
            duckdb_close(&db);
            continue;
        }

        /* Verify changelog table existence */
        if (duckdb_query(conn, "PRAGMA table_info('changelog')", &result) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Table 'changelog' not found in %s\n", db_file);
            duckdb_destroy_result(&result);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }
        idx_t table_rows = duckdb_row_count(&result);
        duckdb_destroy_result(&result);
        if (table_rows == 0) {
            if (verbose >= 1)
                fprintf(stderr, "Table 'changelog' is empty or invalid in %s\n", db_file);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        /* Query changelog table for the latest record matching full_path and name */
        const char *query = "SELECT tfid FROM changelog WHERE full_path = ? AND name = ? LIMIT 1";
        if (verbose >= 4)
            fprintf(stderr, "Preparing query: %s with full_path=%s, name=%s\n", query, dir_path, filename);
        if (duckdb_prepare(conn, query, &stmt) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to prepare query for path resolution in %s: %s\n",
                        db_file, duckdb_result_error(&result) ? duckdb_result_error(&result) : "unknown");
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        if (duckdb_bind_varchar(stmt, 1, dir_path) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to bind parameter: full_path=%s in %s\n", dir_path, db_file);
            duckdb_destroy_prepare(&stmt);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }
        if (duckdb_bind_varchar(stmt, 2, filename) != DuckDBSuccess) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to bind parameter: name=%s in %s\n", filename, db_file);
            duckdb_destroy_prepare(&stmt);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        if (duckdb_execute_prepared(stmt, &result) != DuckDBSuccess) {
            const char *err = duckdb_result_error(&result);
            if (verbose >= 1)
                fprintf(stderr, "Query execution failed for full_path=%s, name=%s in %s: %s\n",
                        dir_path, filename, db_file, err ? err : "unknown");
            duckdb_destroy_result(&result);
            duckdb_destroy_prepare(&stmt);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        if (duckdb_row_count(&result) == 0) {
            if (verbose >= 2)
                fprintf(stderr, "No FID found for full_path=%s, name=%s in database %s\n",
                        dir_path, filename, db_file);
            duckdb_destroy_result(&result);
            duckdb_destroy_prepare(&stmt);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        char *res = duckdb_value_varchar(&result, 0, 0);
        if (!res) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to extract FID from result in %s\n", db_file);
            duckdb_destroy_result(&result);
            duckdb_destroy_prepare(&stmt);
            duckdb_disconnect(&conn);
            duckdb_close(&db);
            continue;
        }

        strncpy(fid, res, fid_len - 1);
        fid[fid_len - 1] = '\0';
        normalize_fid(fid);

        if (verbose >= 3)
            fprintf(stderr, "Resolved FID: %s for full_path=%s, name=%s in %s\n",
                    fid, dir_path, filename, db_file);

        duckdb_free(res);
        duckdb_destroy_result(&result);
        duckdb_destroy_prepare(&stmt);
        duckdb_disconnect(&conn);
        duckdb_close(&db);

        /* Cleanup sorted array */
        for (int j = 0; j < sorted_db_files_total; j++)
            free(sorted_db_files[j]);
        free(sorted_db_files);
        return 0;
    }

    /* Cleanup sorted array */
    for (int j = 0; j < sorted_db_files_total; j++)
        free(sorted_db_files[j]);
    free(sorted_db_files);

    if (verbose >= 1)
        fprintf(stderr, "No FID found for path %s in any database\n", normalized_path);
    return -ENOENT;
}

/*
 * query_loop - Query databases in loop mode for history
 * @fid: FID to query
 * @db_files: List of database file paths
 * @db_files_total: Number of files
 * @list: History list to populate
 *
 * Opens each database file individually, queries the history table for
 * records matching the FID, and adds them to the history list.
 * Skips locked or invalid databases.
 * Returns 0 on success, negative error code on failure.
 */
static int query_loop(const char *fid, char **db_files, int db_files_total,
                      struct history_list *list)
{
        if (verbose >= 3)
                fprintf(stderr, "Querying %d databases in loop mode for FID %s\n",
                        db_files_total, fid);

        if (db_files_total == 0) {
                if (verbose >= 2)
                        fprintf(stderr, "No database files to query\n");
                return 0;
        }

        for (int i = 0; i < db_files_total; i++) {
                duckdb_database db;
                duckdb_connection conn;
                duckdb_config config;
                duckdb_prepared_statement stmt;
                duckdb_result result;
                char *err = NULL;

                if (verbose >= 4)
                        fprintf(stderr, "Opening database %s\n", db_files[i]);
                if (duckdb_create_config(&config) != DuckDBSuccess) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to create DuckDB config for %s\n",
                                        db_files[i]);
                        continue;
                }
                duckdb_set_config(config, "access_mode", "READ_ONLY");
                if (duckdb_open_ext(db_files[i], &db, config, &err) != DuckDBSuccess) {
                        if (verbose >= 2) {
                                if (strstr(err ? err : "", "Could not set lock"))
                                        fprintf(stderr, "Skipping active database %s\n",
                                                db_files[i]);
                                else
                                        fprintf(stderr, "Failed to open %s: %s\n",
                                                db_files[i], err ? err : "unknown");
                        }
                        duckdb_free(err);
                        duckdb_destroy_config(&config);
                        continue;
                }
                duckdb_destroy_config(&config);

                if (verbose >= 5)
                        fprintf(stderr, "Connecting to database %s\n", db_files[i]);
                if (duckdb_connect(db, &conn) != DuckDBSuccess) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to connect to %s\n",
                                        db_files[i]);
                        duckdb_close(&db);
                        continue;
                }

                /* Verify table existence */
                if (verbose >= 6) {
                        if (duckdb_query(conn, "PRAGMA table_info('changelog')", &result) == DuckDBSuccess) {
                                idx_t row_count = duckdb_row_count(&result);
                                fprintf(stderr, "Table 'changelog' in %s has %zu columns\n",
                                        db_files[i], (size_t)row_count);
                                duckdb_destroy_result(&result);
                        } else {
                                fprintf(stderr, "Table 'changelog' not found in %s\n",
                                        db_files[i]);
                        }
                }

		const char *query = "SELECT id, operation_type AS op_type, operation_time AS op_time, flags, tfid, pfid, name, uid, gid, client_nid, job_id, full_path FROM changelog WHERE tfid = ?";
                if (verbose >= 4)
                        fprintf(stderr, "Preparing query: %s with FID=%s\n", query, fid);
                if (duckdb_prepare(conn, query, &stmt) != DuckDBSuccess) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to prepare query for %s: %s\n",
                                        db_files[i], duckdb_result_error(&result) ? duckdb_result_error(&result) : "unknown");
                        duckdb_disconnect(&conn);
                        duckdb_close(&db);
                        continue;
                }

                if (duckdb_bind_varchar(stmt, 1, fid) != DuckDBSuccess) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to bind FID parameter for %s\n",
                                        db_files[i]);
                        duckdb_destroy_prepare(&stmt);
                        duckdb_disconnect(&conn);
                        duckdb_close(&db);
                        continue;
                }

                if (duckdb_execute_prepared(stmt, &result) != DuckDBSuccess) {
                        const char *err = duckdb_result_error(&result);
                        if (verbose >= 2)
                                fprintf(stderr, "Query execution failed for %s: %s\n",
                                        db_files[i], err ? err : "unknown");
                        duckdb_destroy_result(&result);
                        duckdb_destroy_prepare(&stmt);
                        duckdb_disconnect(&conn);
                        duckdb_close(&db);
                        continue;
                }

                idx_t row_count = duckdb_row_count(&result);
                if (verbose >= 5)
                        fprintf(stderr, "Found %zu records in %s for FID %s\n",
                                (size_t)row_count, db_files[i], fid);
                for (idx_t row = 0; row < row_count; row++) {
                        struct history_record *rec = extract_record(&result, row);
                        if (!rec) {
                                if (verbose >= 2)
                                        fprintf(stderr, "Failed to extract record from %s\n",
                                                db_files[i]);
                                continue;
                        }
                        if (add_record(list, rec) != 0) {
                                if (verbose >= 2)
                                        fprintf(stderr, "Failed to add record from %s\n",
                                                db_files[i]);
                                free_record(rec);
                        }
                }

                duckdb_destroy_result(&result);
                duckdb_destroy_prepare(&stmt);
                duckdb_disconnect(&conn);
                duckdb_close(&db);
        }

        if (verbose >= 3)
                fprintf(stderr, "Query loop completed, collected %zu records\n",
                        list->count);
        return 0;
}


/*
 * query_attach - Query history using DuckDB ATTACH for multi-DB
 * @fid: FID to query
 * @db_files: Array of DB paths
 * @db_files_total: Number of DBs
 * @list: History list to populate
 *
 * Attaches DBs to in-memory main DB, queries with UNION. Returns 0 on success, -errno on failure.
 */
static int query_attach(const char *fid, char **db_files, int db_files_total, struct history_list *list)
{
        duckdb_database db;
        duckdb_connection conn;
        duckdb_result result;
        bool attached[MAX_DB_FILES] = {0};  /* Track successful attachments */

        if (verbose >= 3)
                fprintf(stderr, "Starting query_attach for FID %s with %d databases\n", fid, db_files_total);

        /* Open in-memory main database */
        if (duckdb_open(NULL, &db) != DuckDBSuccess) {
                if (verbose >= 1)
                        fprintf(stderr, "Failed to open in-memory DB\n");
                return -EIO;
        }

        if (duckdb_connect(db, &conn) != DuckDBSuccess) {
                if (verbose >= 1)
                        fprintf(stderr, "Failed to connect to in-memory DB\n");
                duckdb_close(&db);
                return -EIO;
        }

        /* Attach all databases */
        int attached_dbs = 0;
        for (int i = 0; i < db_files_total; i++) {
                char attach_query[1024];
                snprintf(attach_query, sizeof(attach_query), "ATTACH '%s' AS db%d (READ_ONLY)", db_files[i], i);
                if (verbose >= 4)
                        fprintf(stderr, "Executing attach query: %s\n", attach_query);
                if (duckdb_query(conn, attach_query, &result) != DuckDBSuccess) {
                        const char *err = duckdb_result_error(&result);
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to attach %s: %s\n", db_files[i], err ? err : "unknown");
                        duckdb_destroy_result(&result);
                        continue;
                }
                duckdb_destroy_result(&result);
                attached[i] = true;
                attached_dbs++;
        }

        if (attached_dbs == 0) {
                if (verbose >= 2)
                        fprintf(stderr, "No databases successfully attached\n");
                duckdb_disconnect(&conn);
                duckdb_close(&db);
                return 0; /* No databases to query, but not an error */
        }

        /* Build the query */
        char query[65536] = "SELECT id, operation_type AS op_type, operation_time AS op_time, "
                          "flags, tfid, pfid, name, uid, gid, client_nid, job_id, full_path "
                          "FROM (";
        size_t query_len = strlen(query);
        int valid_dbs = 0;

        for (int i = 0; i < db_files_total; i++) {
                if (!attached[i]) {
                        if (verbose >= 5)
                                fprintf(stderr, "Skipping verification for db%d (attach failed)\n", i);
                        continue;
                }

                /* Verify table existence */
                char check_query[1024];
                snprintf(check_query, sizeof(check_query), "PRAGMA table_info('db%d.changelog')", i);
                if (verbose >= 5)
                        fprintf(stderr, "Verifying changelog table in db%d: %s\n", i, check_query);
                if (duckdb_query(conn, check_query, &result) == DuckDBSuccess) {
                        idx_t row_count = duckdb_row_count(&result);
                        duckdb_destroy_result(&result);
                        if (row_count > 0) {
                                if (query_len + 300 < sizeof(query)) {  /* Conservative margin */
                                        if (valid_dbs > 0) {
                                                query_len += snprintf(query + query_len, sizeof(query) - query_len, " UNION ALL "); // FIXME this should be configurable with --strip-duplicates or something
                                        }
                                        query_len += snprintf(query + query_len, sizeof(query) - query_len,
                                                              "SELECT id, operation_type, operation_time, flags, tfid, pfid, "
                                                              "name, uid, gid, client_nid, job_id, full_path "
                                                              "FROM db%d.changelog WHERE tfid = '%s' OR pfid = '%s'",
                                                              i, fid, fid);
                                        valid_dbs++;
                                } else {
                                        if (verbose >= 2)
                                                fprintf(stderr, "Query buffer overflow, skipping db%d\n", i);
                                }
                        } else {
                                if (verbose >= 4)
                                        fprintf(stderr, "No changelog table found in db%d\n", i);
                        }
                } else {
                        const char *err = duckdb_result_error(&result);
                        if (verbose >= 4)
                                fprintf(stderr, "Failed to verify changelog table in db%d: %s\n", i, err ? err : "unknown");
                        duckdb_destroy_result(&result);
                }
        }

        if (valid_dbs == 0) {
                if (verbose >= 2)
                        fprintf(stderr, "No valid databases attached for query\n");
                duckdb_disconnect(&conn);
                duckdb_close(&db);
                return 0; /* No databases to query, but not an error */
        }

        query_len += snprintf(query + query_len, sizeof(query) - query_len, ") ORDER BY id");
        if (verbose >= 3)
                fprintf(stderr, "Executing attach query: %s\n", query);

        /* Execute the query */
        if (duckdb_query(conn, query, &result) != DuckDBSuccess) {
                const char *err = duckdb_result_error(&result);
                if (verbose >= 1)
                        fprintf(stderr, "Attach query failed: %s\n", err ? err : "unknown");
                duckdb_destroy_result(&result);
                duckdb_disconnect(&conn);
                duckdb_close(&db);
                return -EIO;
        }

        /* Process results */
        idx_t rows = duckdb_row_count(&result);
        if (verbose >= 3)
                fprintf(stderr, "Query returned %zu rows\n", (size_t)rows);

        for (idx_t row = 0; row < rows; row++) {
                struct history_record *rec = extract_record(&result, row);
                if (!rec) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to extract record at row %zu\n", (size_t)row);
                        continue;
                }
                if (add_record(list, rec) != 0) {
                        if (verbose >= 2)
                                fprintf(stderr, "Failed to add record at row %zu\n", (size_t)row);
                        free_record(rec);
                }
        }

        /* Cleanup */
        duckdb_destroy_result(&result);
        duckdb_disconnect(&conn);
        duckdb_close(&db);

        if (verbose >= 2)
                fprintf(stderr, "Attach query completed, collected %zu records\n", list->count);

        return 0;
}

/*
 * calculate_summary - Calculate summary information for file history
 * @list: History list containing records
 * @mount_point_copy: Local copy of mount_point
 * @file_exists: Output flag indicating if file exists
 * @current_full_path: Output current path of the file
 * @file_name_changed: Output flag indicating if file name changed
 * @same_parent: Output flag indicating if parent directory is the same
 *
 * Analyzes history records to determine original and current file and parent details.
 * Returns 0 on success, negative error code on failure.
 */
static int calculate_summary(struct history_list *list, const char *mount_point_copy,
                            int *file_exists, const char **current_full_path,
                            int *file_name_changed, int *same_parent)
                            // int *parent_exists, int *parent_name_changed)
{
    if (!list || !list->count || !mount_point_copy) {
        *file_exists = 0;
        *current_full_path = "Unavailable (no records or mount point not provided)";
        *file_name_changed = 0;
        *same_parent = 0;
        return 0;
    }

    struct history_record *last = list->records[list->count - 1];
    struct history_record *first = list->records[0];
    char curr_file_path[MAX_PATH] = {0};
    char curr_parent_fid[MAX_FID_LEN] = {0};
    char last_full_path[MAX_PATH];

    construct_full_path(last->full_path, last->name, last_full_path, sizeof(last_full_path));
    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for tfid %s with mount_point %s\n",
                last->tfid, mount_point_copy);
    *file_exists = get_current_path(mount_point_copy, last->tfid,
                                    curr_file_path, sizeof(curr_file_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for tfid, global mount_point: %s, mount_point_copy: %s, file_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                *file_exists, curr_file_path);

    if (*file_exists) {
        *current_full_path = curr_file_path;
        get_parent_fid_from_path(mount_point_copy, curr_file_path, curr_parent_fid, sizeof(curr_parent_fid));
        *file_name_changed = strcmp(basename_safe(curr_file_path), first->name ? first->name : "N/A") != 0;
        *same_parent = strcmp(curr_parent_fid, first->pfid ? first->pfid : "") == 0;
    } else {
        *current_full_path = "Unavailable (file does not exist)";
        *file_name_changed = 0;
        *same_parent = 0;
    }

    return 0;
}

/*
 * utf8_truncate - Truncate a UTF-8 string to a maximum number of display characters
 * @src: Input UTF-8 string to truncate
 * @dest: Destination buffer to store the truncated string
 * @dest_size: Size of the destination buffer (including null terminator)
 * @max_display_chars: Maximum number of display characters (code points) to keep
 *
 * Truncates the source UTF-8 string to at most max_display_chars characters, ensuring
 * complete UTF-8 sequences are copied without breaking multi-byte characters. Assumes
 * src is valid UTF-8 (use is_valid_utf8 to check); invalid sequences are skipped or
 * treated as single bytes. The result is null-terminated and fits within dest_size.
 * Returns the number of bytes written to dest (excluding the null terminator), or 0 on error.
 */
size_t utf8_truncate(const char *src, char *dest, size_t dest_size, size_t max_display_chars) {
    if (!src || !dest || dest_size == 0) return 0;
    size_t chars = 0;
    size_t bytes_written = 0;
    size_t i = 0;
    while (src[i] && chars < max_display_chars && bytes_written < dest_size - 1) {
        unsigned char c = src[i];
        if (c < 0x80) {  // 1-byte char
            dest[bytes_written++] = c;
            i++;
            chars++;
        } else if ((c & 0xE0) == 0xC0 && i + 1 < strlen(src)) {  // 2-byte
            dest[bytes_written++] = c;
            dest[bytes_written++] = src[i + 1];
            i += 2;
            chars++;
        } else if ((c & 0xF0) == 0xE0 && i + 2 < strlen(src)) {  // 3-byte
            dest[bytes_written++] = c;
            dest[bytes_written++] = src[i + 1];
            dest[bytes_written++] = src[i + 2];
            i += 3;
            chars++;
        } else if ((c & 0xF8) == 0xF0 && i + 3 < strlen(src)) {  // 4-byte
            dest[bytes_written++] = c;
            dest[bytes_written++] = src[i + 1];
            dest[bytes_written++] = src[i + 2];
            dest[bytes_written++] = src[i + 3];
            i += 4;
            chars++;
        } else {
            // Invalid, skip or handle
            i++;
        }
    }
    dest[bytes_written] = '\0';
    return bytes_written;
}

/*
 * output_text - Output history records in a basic plain-text format without fancy symbols
 * @list: History list to output
 * @mount_point_copy: Local copy of mount_point to avoid corruption
 * @search_term: The original search term (FID or path)
 * @query_type: 1 if FID lookup, 0 if path lookup
 *
 * Outputs a simple text report: header, record blocks, and summary. Uses plain ASCII for readability.
 */
static void output_text(struct history_list *list, const char *mount_point_copy, const char *search_term, int query_type)
{
    printf("SENTINEL: File Operation History\n");
    printf("============================\n\n");

    if (list->count == 0) {
        printf("No records found.\n\n");
        printf("Summary:\n");
        printf("- Query type: %s\n", query_type ? "FID look up" : "Path look up");
        printf("- Message: No records found\n");
        return;
    }

    printf("Records (%zu total):\n", list->count);
    printf("--------------------\n");
    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));
        printf("Record %zu:\n", i + 1);
        printf("  ID: %lld\n", r->id);
        printf("  Operation: %s\n", translate_op_type(r->op_type));
        printf("  Time: %s\n", r->op_time ? r->op_time : "N/A");
        printf("  Flags: %d\n", r->flags);
        printf("  Target FID: %s\n", r->tfid ? r->tfid : "N/A");
        printf("  Parent FID: %s\n", r->pfid ? r->pfid : "N/A");
        printf("  Name: %s\n", r->name ? r->name : "N/A");
        printf("  UID: %s\n", r->uid ? r->uid : "N/A");
        printf("  GID: %s\n", r->gid ? r->gid : "N/A");
        printf("  Client NID: %s\n", r->client_nid ? r->client_nid : "N/A");
        printf("  Job ID: %s\n", r->job_id ? r->job_id : "N/A");
        printf("  Full Path: %s\n", full_path_buf[0] ? full_path_buf : "N/A");
        printf("\n");
    }

    printf("Summary:\n");
    printf("--------\n");
    if (!mount_point_copy || strlen(mount_point_copy) == 0) {
        printf("- Query type: %s\n", query_type ? "FID look up" : "Path look up");
        printf("- Message: Unavailable (mount point not provided or empty)\n");
        return;
    }

    // Use oldest record (records[0]) for "last" state to match calculate_summary logic
    struct history_record *last = list->records[0];
    char curr_file_path[MAX_PATH] = {0};
    char curr_parent_path[MAX_PATH] = {0};
    char curr_parent_fid[MAX_FID_LEN] = {0};
    char last_full_path[MAX_PATH];
    construct_full_path(last->full_path, last->name, last_full_path, sizeof(last_full_path));
    const char *current_full_path = "Unavailable (no records or mount point not provided)";

    int file_exists = get_current_path(mount_point_copy, last->tfid,
                                       curr_file_path, sizeof(curr_file_path)) == 0;

    int parent_exists = get_current_path(mount_point_copy, last->pfid,
                                         curr_parent_path, sizeof(curr_parent_path)) == 0;

    int same_parent = 0;
    if (file_exists) {
        get_parent_fid_from_path(mount_point_copy, curr_file_path,
                                 curr_parent_fid, sizeof(curr_parent_fid));
        same_parent = (strcmp(curr_parent_fid, last->pfid) == 0);
    }

    if (file_exists) {
        current_full_path = curr_file_path;
    } else {
        current_full_path = "Unavailable (file does not exist)";
    }

    const char *last_name = (last->name && last->name[0] != '\0') ? last->name : "N/A";
    int file_name_changed = file_exists && strcmp(basename_safe(curr_file_path), last_name);

    const char *last_parent_name = basename_safe(dirname_safe(last_full_path));
    int parent_name_changed = parent_exists &&
                              strcmp(basename_safe(curr_parent_path), last_parent_name);

    printf("- Query type: %s\n", query_type ? "FID look up" : "Path look up");
    printf("- File Exists: %s\n", file_exists ? "Yes" : "No");
    printf("- Current Full Path: %s\n", current_full_path);
    printf("- File Name Changed: %s (Last: %s, Current: %s)\n",
           file_name_changed ? "Yes" : "No",
           last_name,
           file_exists ? basename_safe(curr_file_path) : "N/A");
    printf("- Same Parent: %s\n", same_parent ? "Yes" : "No");
    if (!same_parent) {
        printf("- Previous path: %s\n", search_term);
    }
    printf("- Parent Exists: %s\n", parent_exists ? "Yes" : "No");
    printf("- Parent Name Changed: %s\n", parent_name_changed ? "Yes" : "No");
}

/*
 * output_fancy - Output history records in text table format with summary
 * @list: History list to output
 * @mount_point_copy: Local copy of mount_point to avoid corruption
 *
 * Outputs a formatted table with history records and a summary section.
 * Uses dynamic column widths based on content and terminal size.
 */
static void output_fancy(struct history_list *list, const char *mount_point_copy, const char *search_term, int query_type)
{
    if (verbose >= 2)
        fprintf(stderr, "Outputting %zu records in text format, global mount_point: %s, mount_point_copy: %s\n",
                list->count, mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");

    if (verbose >= 3)
        fprintf(stderr, "Starting terminal width detection\n");

    int term_width = 80;
    struct winsize w;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0 && w.ws_col > 0)
        term_width = w.ws_col;
    if (verbose >= 4)
        fprintf(stderr, "Final terminal width: %d columns\n", term_width);

    struct {
        const char *name;
        int min_width;
        int max_width;
        size_t content_max;
    } columns[] = {
        {" ID ", 8, 12, 0}, {" Operation ", 12, 18, 0}, {" Time ", 12, 19, 0},
        {" Flags ", 6, 8, 0}, {" Target FID ", 12, 30, 0}, {" Parent FID ", 12, 30, 0},
        {" Name ", 8, 15, 0}, {" UID ", 6, 10, 0}, {" GID ", 6, 10, 0},
        {" Client NID ", 10, 15, 0}, {" Job ID ", 10, 15, 0}, {" Path ", 15, 30, 0}
    };
    const int num_cols = sizeof(columns) / sizeof(columns[0]);

    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));

        columns[0].content_max = __MAX(columns[0].content_max, (size_t)snprintf(NULL, 0, " %lld ", r->id));
        columns[1].content_max = __MAX(columns[1].content_max, strlen(translate_op_type(r->op_type)) + 2);
        columns[2].content_max = __MAX(columns[2].content_max, r->op_time ? strlen(r->op_time) + 2 : 3);
        columns[3].content_max = __MAX(columns[3].content_max, (size_t)snprintf(NULL, 0, " %d ", r->flags));
        columns[4].content_max = __MAX(columns[4].content_max, r->tfid ? strlen(r->tfid) + 2 : 3);
        columns[5].content_max = __MAX(columns[5].content_max, r->pfid ? strlen(r->pfid) + 2 : 3);

        // Name column (index 6): Use utf8len with validation
        size_t name_display_len = 0;
        if (r->name) {
            if (is_valid_utf8(r->name)) {
                name_display_len = utf8len(r->name);
            } else {
                name_display_len = strlen(r->name);  // Fallback for invalid UTF-8
            }
        }
        columns[6].content_max = __MAX(columns[6].content_max, name_display_len + 2);


        columns[7].content_max = __MAX(columns[7].content_max, r->uid ? strlen(r->uid) + 2 : 3);
        columns[8].content_max = __MAX(columns[8].content_max, r->gid ? strlen(r->gid) + 2 : 3);
        columns[9].content_max = __MAX(columns[9].content_max, r->client_nid ? strlen(r->client_nid) + 2 : 3);
        columns[10].content_max = __MAX(columns[10].content_max, r->job_id ? strlen(r->job_id) + 2 : 3);

        // Path column (index 11): Use utf8len with validation
        size_t path_display_len = 0;
        if (full_path_buf[0]) {
            if (is_valid_utf8(full_path_buf)) {
                path_display_len = utf8len(full_path_buf);
            } else {
                path_display_len = strlen(full_path_buf);  // Fallback
            }
        }
        columns[11].content_max = __MAX(columns[11].content_max, path_display_len + 2);
    }

    for (int i = 0; i < num_cols; i++) {
        columns[i].content_max = __MAX(columns[i].content_max, strlen(columns[i].name));
    }

    int widths[num_cols];
    int total_content_width = 0;

    for (int i = 0; i < num_cols; i++) {
        widths[i] = __MIN(columns[i].content_max, columns[i].max_width);
        widths[i] = __MAX(widths[i], columns[i].min_width);
        total_content_width += widths[i];
    }

    int available_width = term_width - (num_cols + 1);
    if (available_width > total_content_width) {
        int extra = (available_width - total_content_width) / 2;
        widths[6] = __MIN(widths[6] + extra / 2, columns[6].content_max);
        widths[11] = __MIN(widths[11] + (extra - extra / 2), columns[11].content_max);
    } else if (total_content_width > available_width) {
        int excess = total_content_width - available_width;
        widths[11] = __MAX(columns[11].min_width, widths[11] - excess / 2);
        widths[6] = __MAX(columns[6].min_width, widths[6] - (excess - excess / 2));
    }

    total_content_width = 0;
    for (int i = 0; i < num_cols; i++) {
        total_content_width += widths[i];
    }
    int total_table_width = total_content_width + num_cols + 1;

    void print_hline(const char *left, const char *mid, const char *right) {
        printf("%s", left);
        for (int i = 0; i < num_cols; i++) {
            for (int j = 0; j < widths[i]; j++)
                printf("");
            if (i < num_cols - 1)
                printf("%s", mid);
        }
        printf("%s\n", right);
    }

    void print_summary_hline(const char *left, const char *right) {
        printf("%s", left);
        for (int i = 0; i < total_table_width - 2; i++)
            printf("");
        printf("%s\n", right);
    }

    printf("");
    for (int i = 0; i < total_table_width - 2; i++)
        printf("");
    printf("\n");
    printf(" SENTINEL: File Operation History%*s\n", total_table_width - 35, "");
    print_hline("", "", "");

    printf("");
    for (int i = 0; i < num_cols; i++) {
        printf("%-*s", widths[i], columns[i].name);
        if (i < num_cols - 1)
            printf("");
    }
    printf("\n");
    print_hline("", "", "");

    char buf[256];
    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));
        printf("");
        snprintf(buf, sizeof(buf), " %lld ", r->id);
        printf("%-*.*s", widths[0], widths[0], buf);
        snprintf(buf, sizeof(buf), " %s ", translate_op_type(r->op_type));
        printf("%-*.*s", widths[1], widths[1], buf);
        snprintf(buf, sizeof(buf), " %s ", r->op_time ? r->op_time : " N/A ");
        printf("%-*.*s", widths[2], widths[2], buf);
        snprintf(buf, sizeof(buf), " %d ", r->flags);
        printf("%-*.*s", widths[3], widths[3], buf);
        snprintf(buf, sizeof(buf), " %s ", r->tfid ? r->tfid : " N/A ");
        printf("%-*.*s", widths[4], widths[4], buf);
        snprintf(buf, sizeof(buf), " %s ", r->pfid ? r->pfid : " N/A ");
        printf("%-*.*s", widths[5], widths[5], buf);
        snprintf(buf, sizeof(buf), " %s ", r->name ? r->name : " N/A ");
        printf("%-*.*s", widths[6], widths[6], buf);
        snprintf(buf, sizeof(buf), " %s ", r->uid ? r->uid : " N/A ");
        printf("%-*.*s", widths[7], widths[7], buf);
        snprintf(buf, sizeof(buf), " %s ", r->gid ? r->gid : " N/A ");
        printf("%-*.*s", widths[8], widths[8], buf);
        snprintf(buf, sizeof(buf), " %s ", r->client_nid ? r->client_nid : " N/A ");
        printf("%-*.*s", widths[9], widths[9], buf);
        snprintf(buf, sizeof(buf), " %s ", r->job_id ? r->job_id : " N/A ");
        printf("%-*.*s", widths[10], widths[10], buf);
        snprintf(buf, sizeof(buf), " %.253s ", full_path_buf[0] ? full_path_buf : " N/A ");
        printf("%-*.*s\n", widths[11], widths[11], buf);
    }

    print_hline("", "", "");
    char count_str[32];
    snprintf(count_str, sizeof(count_str), "%zu", list->count);
    int footer_width = total_table_width - 17 - (int)strlen(count_str);
    printf(" Total records: %zu%*s\n", list->count, footer_width - 1, "");
    print_summary_hline("", "");

    /* Summary section within table */
    if (list->count == 0) {
        printf(" Summary: No records found%*s\n", total_table_width - 28, "");
        print_summary_hline("", "");
        return;
    }
    if (!mount_point_copy || strlen(mount_point_copy) == 0) {
        printf(" Summary: Unavailable (mount point not provided or empty)%*s\n",
               total_table_width - 59, "");
        if (verbose >= 1)
            fprintf(stderr, "Summary unavailable, global mount_point: %s, mount_point_copy: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");
        print_summary_hline("", "");
        return;
    }

    if (verbose >= 3)
        fprintf(stderr, "Starting summary, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    int file_exists, same_parent, file_name_changed;
    const char *current_full_path;
    if (calculate_summary(list, mount_point_copy, &file_exists, &current_full_path,
                         &file_name_changed, &same_parent) < 0) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to calculate summary\n");
        printf(" Summary: Failed to calculate%*s\n", total_table_width - 30, "");
        print_summary_hline("", "");
        return;
    }

    if (verbose >= 3)
        fprintf(stderr, "Summary calculated, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    printf(" Summary:%*s\n", total_table_width - 11, "");

   snprintf(buf, sizeof(buf), "Query type: %s", query_type ? "FID look up" : "Path look up");
   printf("   %-*s\n", total_table_width - 5, buf);

    snprintf(buf, sizeof(buf), "File Exists: %s", file_exists ? "Yes" : "No");
    printf("   %-*s\n", total_table_width - 5, buf);
    snprintf(buf, sizeof(buf), "Current Full Path: %s", current_full_path);
    printf("   %-*s\n", total_table_width - 5, buf);
    snprintf(buf, sizeof(buf), "File Name Changed: %s (Last: %s, Current: %s)",
             file_name_changed ? "Yes" : "No",
             list->records[0]->name ? list->records[0]->name : "N/A",
             file_exists ? basename_safe(current_full_path) : "N/A");
    printf("   %-*s\n", total_table_width - 5, buf);

    if (same_parent) {
    	snprintf(buf, sizeof(buf), "Same Parent: Yes");
    	printf("   %-*s\n", total_table_width - 5, buf);
    } else {
    	snprintf(buf, sizeof(buf), "Same Parent: No");
    	printf("   %-*s\n", total_table_width - 5, buf);
        snprintf(buf, sizeof(buf), "Previous path: %s", search_term);  // Now uses passed search_term
    	printf("   %-*s\n", total_table_width - 5, buf);
    }
    print_summary_hline("", "");
}

/*
 * output_yaml - Output history records in YAML format with summary
 * @list: History list to output
 * @mount_point_copy: Local copy of mount_point to avoid corruption
 * @search_term: The original search term (FID or path)
 * @query_type: 1 if FID lookup, 0 if path lookup
 *
 * Outputs YAML with history list and summary section.
 */
static void output_yaml(struct history_list *list, const char *mount_point_copy, const char *search_term, int query_type)
{
    if (verbose >= 2)
        fprintf(stderr, "Outputting %zu records in YAML format, global mount_point: %s, mount_point_copy: %s\n",
                list->count, mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");

    printf("history:\n");
    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));
        printf("  - id: %lld\n    type: %s\n    time: %s\n    flags: %d\n"
               "    tfid: %s\n    pfid: %s\n    name: %s\n    uid: %s\n"
               "    gid: %s\n    client_nid: %s\n    job_id: %s\n"
               "    full_path: %s\n",
               r->id, translate_op_type(r->op_type),
               r->op_time ? r->op_time : "", r->flags,
               r->tfid ? r->tfid : "", r->pfid ? r->pfid : "",
               r->name ? r->name : "", r->uid ? r->uid : "",
               r->gid ? r->gid : "", r->client_nid ? r->client_nid : "",
               r->job_id ? r->job_id : "", full_path_buf[0] ? full_path_buf : "");
    }

    if (list->count == 0) {
        printf("summary:\n  message: No records found\n");
        return;
    }

    if (!mount_point_copy || strlen(mount_point_copy) == 0) {
        printf("summary: Unavailable (mount point not provided or empty)\n");
        if (verbose >= 1)
            fprintf(stderr, "Summary unavailable, global mount_point: %s, mount_point_copy: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");
        return;
    }

    if (verbose >= 3)
        fprintf(stderr, "Starting summary, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    // Use oldest record (records[0]) for "last" state to match calculate_summary logic
    if (list->count == 0) return;  // Already handled above
    struct history_record *last = list->records[0];  // Fixed: Use records[0] instead of [count-1]
    char curr_file_path[MAX_PATH] = {0};
    char curr_parent_path[MAX_PATH] = {0};
    char curr_parent_fid[MAX_FID_LEN] = {0};
    char last_full_path[MAX_PATH];
    construct_full_path(last->full_path, last->name, last_full_path, sizeof(last_full_path));
    const char *current_full_path = "Unavailable (no records or mount point not provided)";

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for tfid %s with mount_point %s\n",
                last->tfid, mount_point_copy);
    int file_exists = get_current_path(mount_point_copy, last->tfid,
                                       curr_file_path, sizeof(curr_file_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for tfid, global mount_point: %s, mount_point_copy: %s, file_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                file_exists, curr_file_path);

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for pfid %s with mount_point %s\n",
                last->pfid, mount_point_copy);
    int parent_exists = get_current_path(mount_point_copy, last->pfid,
                                         curr_parent_path, sizeof(curr_parent_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for pfid, global mount_point: %s, mount_point_copy: %s, parent_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                parent_exists, curr_parent_path);

    int same_parent = 0;
    if (file_exists) {
        if (verbose >= 5)
            fprintf(stderr, "Calling get_parent_fid_from_path for path %s with mount_point %s\n",
                    curr_file_path, mount_point_copy);
        get_parent_fid_from_path(mount_point_copy, curr_file_path,
                                 curr_parent_fid, sizeof(curr_parent_fid));
        if (verbose >= 5)
            fprintf(stderr, "After get_parent_fid_from_path, global mount_point: %s, mount_point_copy: %s, curr_parent_fid: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                    curr_parent_fid);
        same_parent = (strcmp(curr_parent_fid, last->pfid) == 0);
    }

    if (file_exists) {
        current_full_path = curr_file_path;
    } else {
        current_full_path = "Unavailable (file does not exist)";
    }

    // Fixed: Proper check for non-empty name
    const char *last_name = (last->name && last->name[0] != '\0') ? last->name : "N/A";
    int file_name_changed = file_exists && strcmp(basename_safe(curr_file_path), last_name);

    const char *last_parent_name = basename_safe(dirname_safe(last_full_path));
    int parent_name_changed = parent_exists &&
                              strcmp(basename_safe(curr_parent_path), last_parent_name);

    if (verbose >= 3)
        fprintf(stderr, "Summary calculated, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    printf("summary:\n");
    printf("  query_type: %s\n", query_type ? "FID look up" : "Path look up");
    printf("  file_exists: %s\n", file_exists ? "true" : "false");
    printf("  current_full_path: %s\n", current_full_path);
    printf("  file_name_changed: %s\n", file_name_changed ? "true" : "false");
    printf("  same_parent: %s\n", same_parent ? "true" : "false");
    if (!same_parent) {
        printf("  previous_path: %s\n", search_term);
    }
    printf("  parent_exists: %s\n", parent_exists ? "true" : "false");
    printf("  parent_name_changed: %s\n", parent_name_changed ? "true" : "false");
}

/*
 * output_json - Output history records in JSON format with summary
 * @list: History list to output
 * @mount_point_copy: Local copy of mount_point to avoid corruption
 * @search_term: The original search term (FID or path)
 * @query_type: 1 if FID lookup, 0 if path lookup
 *
 * Outputs JSON object with "history" array and "summary" object.
 */
static void output_json(struct history_list *list, const char *mount_point_copy, const char *search_term, int query_type)
{
    if (verbose >= 2)
        fprintf(stderr, "Outputting %zu records in JSON format, global mount_point: %s, mount_point_copy: %s\n",
                list->count, mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");

    printf("{\"history\":[");
    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));
        printf("{\"id\":%lld,\"type\":\"%s\",\"time\":\"%s\",\"flags\":%d,"
               "\"tfid\":\"%s\",\"pfid\":\"%s\",\"name\":\"%s\",\"uid\":\"%s\","
               "\"gid\":\"%s\",\"client_nid\":\"%s\",\"job_id\":\"%s\","
               "\"full_path\":\"%s\"}",
               r->id, translate_op_type(r->op_type),
               r->op_time ? r->op_time : "", r->flags,
               r->tfid ? r->tfid : "", r->pfid ? r->pfid : "",
               r->name ? r->name : "", r->uid ? r->uid : "",
               r->gid ? r->gid : "", r->client_nid ? r->client_nid : "",
               r->job_id ? r->job_id : "", full_path_buf[0] ? full_path_buf : "");
        if (i < list->count - 1)
            printf(",");
    }
    printf("],");

    if (list->count == 0) {
        printf("\"summary\":{\"message\":\"No records found\"}}\n");
        return;
    }

    if (!mount_point_copy || strlen(mount_point_copy) == 0) {
        printf("\"summary\":{\"message\":\"Unavailable (mount point not provided or empty)\"}}\n");
        if (verbose >= 1)
            fprintf(stderr, "Summary unavailable, global mount_point: %s, mount_point_copy: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");
        return;
    }

    if (verbose >= 3)
        fprintf(stderr, "Starting summary, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    // Use oldest record (records[0]) for "last" state to match calculate_summary logic
    if (list->count == 0) return;  // Already handled above
    struct history_record *last = list->records[0];  // Fixed: Use records[0] instead of [count-1]
    char curr_file_path[MAX_PATH] = {0};
    char curr_parent_path[MAX_PATH] = {0};
    char curr_parent_fid[MAX_FID_LEN] = {0};
    char last_full_path[MAX_PATH];
    construct_full_path(last->full_path, last->name, last_full_path, sizeof(last_full_path));
    const char *current_full_path = "Unavailable (no records or mount point not provided)";

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for tfid %s with mount_point %s\n",
                last->tfid, mount_point_copy);
    int file_exists = get_current_path(mount_point_copy, last->tfid,
                                       curr_file_path, sizeof(curr_file_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for tfid, global mount_point: %s, mount_point_copy: %s, file_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                file_exists, curr_file_path);

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for pfid %s with mount_point %s\n",
                last->pfid, mount_point_copy);
    int parent_exists = get_current_path(mount_point_copy, last->pfid,
                                         curr_parent_path, sizeof(curr_parent_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for pfid, global mount_point: %s, mount_point_copy: %s, parent_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                parent_exists, curr_parent_path);

    int same_parent = 0;
    if (file_exists) {
        if (verbose >= 5)
            fprintf(stderr, "Calling get_parent_fid_from_path for path %s with mount_point %s\n",
                    curr_file_path, mount_point_copy);
        get_parent_fid_from_path(mount_point_copy, curr_file_path,
                                 curr_parent_fid, sizeof(curr_parent_fid));
        if (verbose >= 5)
            fprintf(stderr, "After get_parent_fid_from_path, global mount_point: %s, mount_point_copy: %s, curr_parent_fid: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                    curr_parent_fid);
        same_parent = (strcmp(curr_parent_fid, last->pfid) == 0);
    }

    if (file_exists) {
        current_full_path = curr_file_path;
    } else {
        current_full_path = "Unavailable (file does not exist)";
    }

    // Fixed: Proper check for non-empty name
    const char *last_name = (last->name && last->name[0] != '\0') ? last->name : "N/A";
    int file_name_changed = file_exists && strcmp(basename_safe(curr_file_path), last_name);

    const char *last_parent_name = basename_safe(dirname_safe(last_full_path));
    int parent_name_changed = parent_exists &&
                              strcmp(basename_safe(curr_parent_path), last_parent_name);

    if (verbose >= 3)
        fprintf(stderr, "Summary calculated, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    printf("\"summary\":{\"query_type\":\"%s\",\"file_exists\":%s,\"current_full_path\":\"%s\",\"file_name_changed\":%s,"
           "\"same_parent\":%s",
           query_type ? "FID look up" : "Path look up",
           file_exists ? "true" : "false",
           current_full_path,
           file_name_changed ? "true" : "false",
           same_parent ? "true" : "false");
    if (!same_parent) {
        printf(",\"previous_path\":\"%s\"", search_term);
    }
    printf(",\"parent_exists\":%s,\"parent_name_changed\":%s}}\n",
           parent_exists ? "true" : "false",
           parent_name_changed ? "true" : "false");
}

/*
 * output_csv - Output history records in CSV format with summary
 * @list: History list to output
 * @mount_point_copy: Local copy of mount_point to avoid corruption
 * @search_term: The original search term (FID or path)
 * @query_type: 1 if FID lookup, 0 if path lookup
 *
 * Outputs CSV rows for records, followed by summary comments.
 */
static void output_csv(struct history_list *list, const char *mount_point_copy, const char *search_term, int query_type)
{
    if (verbose >= 2)
        fprintf(stderr, "Outputting %zu records in CSV format, global mount_point: %s, mount_point_copy: %s\n",
                list->count, mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");

    printf("id,type,time,flags,tfid,pfid,name,uid,gid,client_nid,job_id,full_path\n");
    for (size_t i = 0; i < list->count; i++) {
        struct history_record *r = list->records[i];
        char full_path_buf[MAX_PATH];
        construct_full_path(r->full_path, r->name, full_path_buf, sizeof(full_path_buf));
        printf("%lld,\"%s\",\"%s\",%d,\"%s\",\"%s\",\"%s\",\"%s\",\"%s\","
               "\"%s\",\"%s\",\"%s\"\n",
               r->id, translate_op_type(r->op_type),
               r->op_time ? r->op_time : "", r->flags,
               r->tfid ? r->tfid : "", r->pfid ? r->pfid : "",
               r->name ? r->name : "", r->uid ? r->uid : "",
               r->gid ? r->gid : "", r->client_nid ? r->client_nid : "",
               r->job_id ? r->job_id : "", full_path_buf[0] ? full_path_buf : "");
    }

    if (list->count == 0) {
        printf("# Summary: No records found\n");
        return;
    }

    if (!mount_point_copy || strlen(mount_point_copy) == 0) {
        printf("# Summary: Unavailable (mount point not provided or empty)\n");
        if (verbose >= 1)
            fprintf(stderr, "Summary unavailable, global mount_point: %s, mount_point_copy: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");
        return;
    }

    if (verbose >= 3)
        fprintf(stderr, "Starting summary, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    // Use oldest record (records[0]) for "last" state to match calculate_summary logic
    if (list->count == 0) return;  // Already handled above
    struct history_record *last = list->records[0];  // Fixed: Use records[0] instead of [count-1]
    char curr_file_path[MAX_PATH] = {0};
    char curr_parent_path[MAX_PATH] = {0};
    char curr_parent_fid[MAX_FID_LEN] = {0};
    char last_full_path[MAX_PATH];
    construct_full_path(last->full_path, last->name, last_full_path, sizeof(last_full_path));
    const char *current_full_path = "Unavailable (no records or mount point not provided)";

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for tfid %s with mount_point %s\n",
                last->tfid, mount_point_copy);
    int file_exists = get_current_path(mount_point_copy, last->tfid,
                                       curr_file_path, sizeof(curr_file_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for tfid, global mount_point: %s, mount_point_copy: %s, file_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                file_exists, curr_file_path);

    if (verbose >= 5)
        fprintf(stderr, "Calling get_current_path for pfid %s with mount_point %s\n",
                last->pfid, mount_point_copy);
    int parent_exists = get_current_path(mount_point_copy, last->pfid,
                                         curr_parent_path, sizeof(curr_parent_path)) == 0;
    if (verbose >= 5)
        fprintf(stderr, "After get_current_path for pfid, global mount_point: %s, mount_point_copy: %s, parent_exists: %d, path: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                parent_exists, curr_parent_path);

    int same_parent = 0;
    if (file_exists) {
        if (verbose >= 5)
            fprintf(stderr, "Calling get_parent_fid_from_path for path %s with mount_point %s\n",
                    curr_file_path, mount_point_copy);
        get_parent_fid_from_path(mount_point_copy, curr_file_path,
                                 curr_parent_fid, sizeof(curr_parent_fid));
        if (verbose >= 5)
            fprintf(stderr, "After get_parent_fid_from_path, global mount_point: %s, mount_point_copy: %s, curr_parent_fid: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)",
                    curr_parent_fid);
        same_parent = (strcmp(curr_parent_fid, last->pfid) == 0);
    }

    if (file_exists) {
        current_full_path = curr_file_path;
    } else {
        current_full_path = "Unavailable (file does not exist)";
    }

    // Fixed: Proper check for non-empty name
    const char *last_name = (last->name && last->name[0] != '\0') ? last->name : "N/A";
    int file_name_changed = file_exists && strcmp(basename_safe(curr_file_path), last_name);

    const char *last_parent_name = basename_safe(dirname_safe(last_full_path));
    int parent_name_changed = parent_exists &&
                              strcmp(basename_safe(curr_parent_path), last_parent_name);

    if (verbose >= 3)
        fprintf(stderr, "Summary calculated, global mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy);

    printf("# Summary:\n");
    printf("# query_type,%s\n", query_type ? "FID look up" : "Path look up");
    printf("# file_exists,%s\n", file_exists ? "true" : "false");
    printf("# current_full_path,%s\n", current_full_path);
    printf("# file_name_changed,%s\n", file_name_changed ? "true" : "false");
    printf("# same_parent,%s\n", same_parent ? "true" : "false");
    if (!same_parent) {
        printf("# previous_path,%s\n", search_term);
    }
    printf("# parent_exists,%s\n", parent_exists ? "true" : "false");
    printf("# parent_name_changed,%s\n", parent_name_changed ? "true" : "false");
}

/* print_help - Display usage information and options
 * @prog: Program name (argv[0])
 *
 * Prints help message to stdout.
 */
static void print_help(const char *prog)
{
	printf("Lustre Sentinel search version %s\n\n", VERSION);
	printf("Usage: %s [options] <search_term>\n", prog);
	printf("<search_term> is the last argument: FID (e.g., [0x...]) or path.\n\n");
	printf("Options:\n");
	printf("  -D, --db <arg>         Database path/dir, glob (*.db), template (%%d.db), or files\n");
	printf("  -m, --mount <path>     Lustre mount point for live checks\n");
	printf("  -f, --format <fmt>     Output: text, yaml, json, csv (default: text)\n");
	printf("  -M, --method <meth>    Query method: attach or loop (default: attach)\n");
	printf("  -o, --output <file>    Write output to file (default: stdout)\n");
	printf("  -c, --config <file>    Load configuration from file\n");
	printf("  -v, --verbose <level>  Verbosity (1=simple, 10=everything)\n");
	printf("  -h, --help             This help\n");
    	printf("\nVisit https://github.com/cfaber/Lustre-Sentinel for more information\n\n");
}

/*
 * parse_config - Parse configuration file for options
 * @config_file: Path to config file
 * @db_arg: Pointer to db argument string
 * @mount_point: Pointer to mount point
 * @format: Pointer to format string
 * @method: Pointer to method string
 * @output_file: Pointer to output file
 * @verbose: Pointer to verbose level
 *
 * Reads key=value lines from file, sets options. Returns 0 on success, -1 on error.
 */
static int parse_config(const char *config_file, char **db_arg, char **mount_point,
                        char **format, char **method, char **output_file, int *verbose)
{
    FILE *fp = fopen(config_file, "r");
    if (!fp) {
        if (*verbose >= 1)
            fprintf(stderr, "Error opening config %s: %s\n", config_file, strerror(errno));
        return -1;
    }
    char line[1024];
    while (fgets(line, sizeof(line), fp)) {
        char *key = strtok(line, "=");
        char *val = strtok(NULL, "\n");
        if (!key || !val) continue;
        if (strcmp(key, "db") == 0 && val && strlen(val) > 0) {
            free(*db_arg);
            *db_arg = strdup(val);
            if (!*db_arg) {
                if (*verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for db_arg from config\n");
                fclose(fp);
                return -1;
            }
            if (*verbose >= 3)
                fprintf(stderr, "Set db_arg from config: %s\n", *db_arg);
        } else if (strcmp(key, "mount") == 0 && val && strlen(val) > 0) {
            free(*mount_point);
            *mount_point = strdup(val);
            if (!*mount_point) {
                if (*verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for mount_point from config\n");
                fclose(fp);
                return -1;
            }
            if (*verbose >= 3)
                fprintf(stderr, "Set mount_point from config: %s\n", *mount_point);
        } else if (strcmp(key, "format") == 0 && val && strlen(val) > 0) {
            free(*format);
            *format = strdup(val);
            if (!*format) {
                if (*verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for format from config\n");
                fclose(fp);
                return -1;
            }
            if (*verbose >= 3)
                fprintf(stderr, "Set format from config: %s\n", *format);
        } else if (strcmp(key, "method") == 0 && val && strlen(val) > 0) {
            free(*method);
            *method = strdup(val);
            if (!*method) {
                if (*verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for method from config\n");
                fclose(fp);
                return -1;
            }
            if (*verbose >= 3)
                fprintf(stderr, "Set method from config: %s\n", *method);
        } else if (strcmp(key, "output") == 0 && val && strlen(val) > 0) {
            free(*output_file);
            *output_file = strdup(val);
            if (!*output_file) {
                if (*verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for output_file from config\n");
                fclose(fp);
                return -1;
            }
            if (*verbose >= 3)
                fprintf(stderr, "Set output_file from config: %s\n", *output_file);
        } else if (strcmp(key, "verbose") == 0 && val) {
            *verbose = atoi(val);
            if (*verbose < 1 || *verbose > 10)
                *verbose = 1;
            if (*verbose >= 3)
                fprintf(stderr, "Set verbose from config: %d\n", *verbose);
        }
    }
    fclose(fp);
    if (*verbose >= 2)
        fprintf(stderr, "After config parsing, mount_point: %s\n", *mount_point ? *mount_point : "(null)");
    return 0;
}

/*
 * main - Entry point for Lustre Sentinel file history query tool
 * @argc: Number of command-line arguments
 * @argv: Array of command-line arguments
 *
 * Parses command-line options and config file, collects database files,
 * queries file history by FID or path, and outputs results in specified format.
 * The last non-option argument is the search term (FID or path). Returns 0 on
 * success, 1 on error.
 */
int main(int argc, char *argv[])
{
    char *search_term = NULL;
    char *db_arg = NULL;
    char *format = NULL;
    char *method = NULL;
    char *output_file = NULL;
    char *config_file = NULL;
    char *mount_point = NULL;
    char *fid = NULL;
    char *normalized_path = NULL;
    char **db_files = NULL;
    char **db_files_list = NULL;
    int db_files_total = 0;
    int db_files_count = 0;
    int rc = 0;
    const char *db_glob = NULL;
    const char *db_template = NULL;
    const char *db_path = NULL;

    // Defaults
    format = strdup("text");
    method = strdup("attach");

    if (!format) {
        fprintf(stderr, "Failed to allocate memory for format\n");
        rc = 1;
        goto cleanup;
    }
    if (!method) {
        fprintf(stderr, "Failed to allocate memory for method\n");
        rc = 1;
        goto cleanup;
    }

    if (verbose >= 1)
        fprintf(stderr, "Program started, stderr test\n");

    // Process argv twice, this is the first time to grab help
    // verbose and config. Then process it a second time
    // and over-write any the config options
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-c") == 0 || strcmp(argv[i], "--config") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -c/--config\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }
            free(config_file);
            config_file = strdup(argv[++i]);
            if (!config_file) {
                fprintf(stderr, "Failed to allocate memory for config_file\n");
                rc = 1;
                goto cleanup;
            }
            if (verbose >= 3)
                fprintf(stderr, "Set config_file: %s\n", config_file);
        } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
	    if (verbose) {
		fprintf(stderr, "Verbose argument called more than once!\n");
		print_help(argv[0]);
		rc = 1;
		goto cleanup;
	    } else if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -v/--verbose\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }
            verbose = atoi(argv[++i]);
            if (verbose < 1 || verbose > 10)
                verbose = 1;
            if (verbose >= 3)
                fprintf(stderr, "Set verbose level: %d\n", verbose);
        } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            print_help(argv[0]);
            goto cleanup;
	}
    }

    if (config_file) {
        if (verbose >= 2)
            fprintf(stderr, "Loading config file: %s\n", config_file);
        if (parse_config(config_file, &db_arg, &mount_point, &format, &method, &output_file, &verbose) < 0) {
            fprintf(stderr, "Failed to parse config file: %s\n", config_file);
            rc = 1;
            goto cleanup;
        }
    }

    // Second round with argv (hopefully this isn't too long =)
    for (int i = 1; i < argc; i++) {
	// Skip these since we've already processed them.
        if (strcmp(argv[i], "-c") == 0 ||
	    strcmp(argv[i], "--config") == 0 || 
	    strcmp(argv[i], "-v") == 0 || 
	    strcmp(argv[i], "--verbose") == 0){
		++i;
	    continue;
	} else if (strcmp(argv[i], "-h") == 0 || 
	    strcmp(argv[i], "--help") == 0) {
	    continue;
	}

        if (strcmp(argv[i], "-D") == 0 || strcmp(argv[i], "--db") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -D/--db\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }
            free(db_arg);
            db_arg = strdup(argv[++i]);
            if (!db_arg) {
                fprintf(stderr, "Failed to allocate memory for db_arg\n");
                rc = 1;
                goto cleanup;
            }
            if (verbose >= 3)
                fprintf(stderr, "Set db_arg: %s\n", db_arg);

	} else if (strcmp(argv[i], "-m") == 0 || strcmp(argv[i], "--mount") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -m/--mount\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }

            free(mount_point);
            mount_point = strdup(argv[++i]);

            if (!mount_point) {
                fprintf(stderr, "Failed to allocate memory for mount_point\n");
                rc = 1;
                goto cleanup;
            }

            if (verbose >= 3)
                fprintf(stderr, "Set mount_point: %s\n", mount_point);
        } else if (strcmp(argv[i], "-f") == 0 || strcmp(argv[i], "--format") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -f/--format\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }

            free(format);
            format = strdup(argv[++i]);

            if (!format) {
                fprintf(stderr, "Failed to allocate memory for format\n");
                rc = 1;
                goto cleanup;
            }

            if (verbose >= 3)
                fprintf(stderr, "Set format: %s\n", format);
        } else if (strcmp(argv[i], "-M") == 0 || strcmp(argv[i], "--method") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -M/--method\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }
            free(method);

            method = strdup(argv[++i]);

            if (!method) {
                fprintf(stderr, "Failed to allocate memory for method\n");
                rc = 1;
                goto cleanup;
            }
            if (verbose >= 3)
                fprintf(stderr, "Set method: %s\n", method);
        } else if (strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "--output") == 0) {
            if (i + 1 >= argc) {
                fprintf(stderr, "Missing argument for -o/--output\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }

            free(output_file);
            output_file = strdup(argv[++i]);

            if (!output_file) {
                fprintf(stderr, "Failed to allocate memory for output_file\n");
                rc = 1;
                goto cleanup;
            }

            if (verbose >= 3)
                fprintf(stderr, "Set output_file: %s\n", output_file);
        } else {
            if (search_term) {
                fprintf(stderr, "Multiple search terms provided\n");
                print_help(argv[0]);
                rc = 1;
                goto cleanup;
            }

            search_term = strdup(argv[i]);
            
	    if (!search_term) {
                fprintf(stderr, "Failed to allocate memory for search_term\n");
                rc = 1;
                goto cleanup;
            }
            if (verbose >= 3)
                fprintf(stderr, "Set search_term: %s\n", search_term);
        }
    } // end of for()

    // special processing for mount point
    if (mount_point && geteuid() != 0) {
        fprintf(stderr, "This program must be run as root when using the -m (mount) option as root is required to access FID data on files.\n");
        rc = 1;
        goto cleanup;
    }

    // special processing for db_arg
    if (db_arg && db_arg[0] == '\0') {
        if (verbose >= 1)
            fprintf(stderr, "Empty db argument provided\n");
        fprintf(stderr, "ERROR: Empty db argument provided\n");
        rc = 1;
        goto cleanup;
    } else if (db_arg) {
        struct stat st;
        // Check if db_arg is a single existing regular file or symlink
        if (stat(db_arg, &st) == 0 && (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))) {
            db_files_list = malloc(sizeof(char *));
            if (!db_files_list) {
                if (verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for db_files_list\n");
                rc = 1;
                goto cleanup;
            }
            db_files_list[0] = strdup(db_arg);
            if (!db_files_list[0]) {
                if (verbose >= 1)
                    fprintf(stderr, "Failed to duplicate db_arg: %s\n", db_arg);
                free(db_files_list);
                db_files_list = NULL;
                rc = 1;
                goto cleanup;
            }
            db_files_count = 1;
            if (verbose >= 4)
                fprintf(stderr, "db_arg is single file: %s\n", db_files_list[0]);
        } else if (strstr(db_arg, "%")) {
            // Check for template and validate directory
            char dir_copy[MAX_PATH];
            strncpy(dir_copy, db_arg, sizeof(dir_copy) - 1);
            dir_copy[sizeof(dir_copy) - 1] = '\0';
            char *dir = dirname(dir_copy);
            if (stat(dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
                if (verbose >= 1)
                    fprintf(stderr, "Invalid directory for template pattern: %s\n", dir);
                fprintf(stderr, "ERROR: Invalid directory for template pattern: %s\n", dir);
                rc = 1;
                goto cleanup;
            }
            db_template = db_arg;
            if (verbose >= 4)
                fprintf(stderr, "db_arg is template: %s (directory validated: %s)\n", db_template, dir);
        } else if (strchr(db_arg, '*') || strchr(db_arg, '?')) {
            // Check for glob pattern and validate directory
            char dir_copy[MAX_PATH];
            strncpy(dir_copy, db_arg, sizeof(dir_copy) - 1);
            dir_copy[sizeof(dir_copy) - 1] = '\0';
            char *dir = dirname(dir_copy);
            if (stat(dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
                if (verbose >= 1)
                    fprintf(stderr, "Invalid directory for glob pattern: %s\n", dir);
                fprintf(stderr, "ERROR: Invalid directory for glob pattern: %s\n", dir);
                rc = 1;
                goto cleanup;
            }
            db_glob = db_arg;
            if (verbose >= 4)
                fprintf(stderr, "db_arg is glob: %s (directory validated: %s)\n", db_glob, dir);
        } else if (strchr(db_arg, ' ')) {
            // Check for space-separated files and validate each file
            char *db_arg_copy = strdup(db_arg);
            if (!db_arg_copy) {
                if (verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for db_arg_copy\n");
                rc = 1;
                goto cleanup;
            }
            char *token = strtok(db_arg_copy, " ");
            db_files_count = 0;
            db_files_list = malloc(MAX_DB_FILES * sizeof(char *));
            if (!db_files_list) {
                if (verbose >= 1)
                    fprintf(stderr, "Failed to allocate memory for db_files_list\n");
                free(db_arg_copy);
                rc = 1;
                goto cleanup;
            }
            while (token && db_files_count < MAX_DB_FILES) {
                if (!token[0]) {
                    if (verbose >= 1)
                        fprintf(stderr, "Empty file name in db argument\n");
                    fprintf(stderr, "ERROR: Empty file name in db argument\n");
                    for (int k = 0; k < db_files_count; k++)
                        free(db_files_list[k]);
                    free(db_files_list);
                    db_files_list = NULL;
                    free(db_arg_copy);
                    rc = 1;
                    goto cleanup;
                }
                db_files_list[db_files_count] = strdup(token);
                if (!db_files_list[db_files_count]) {
                    if (verbose >= 1)
                        fprintf(stderr, "Failed to duplicate db file path: %s\n", token);
                    for (int j = 0; j < db_files_count; j++)
                        free(db_files_list[j]);
                    free(db_files_list);
                    db_files_list = NULL;
                    free(db_arg_copy);
                    rc = 1;
                    goto cleanup;
                }
                db_files_count++;
                token = strtok(NULL, " ");
            }

            free(db_arg_copy);

            // Validate each file in the list
            for (int j = 0; j < db_files_count; j++) {
                if (stat(db_files_list[j], &st) != 0 || !(S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))) {
                    if (verbose >= 1)
                        fprintf(stderr, "Invalid file in db argument: %s\n", db_files_list[j]);
                    fprintf(stderr, "ERROR: Invalid file in db argument: %s\n", db_files_list[j]);
                    for (int k = 0; k < db_files_count; k++)
                        free(db_files_list[k]);
                    free(db_files_list);
                    db_files_list = NULL;
                    rc = 1;
                    goto cleanup;
                }
            }
            if (verbose >= 4)
                fprintf(stderr, "Validated %d space-separated db files\n", db_files_count);
        } else if (stat(db_arg, &st) == 0 && S_ISDIR(st.st_mode)) {
            // Check for directory
            db_path = db_arg;
            if (verbose >= 4)
                fprintf(stderr, "db_arg is directory: %s\n", db_path);
        } else {
            if (verbose >= 1)
                fprintf(stderr, "Invalid db argument: %s\n", db_arg);
            fprintf(stderr, "ERROR: Invalid db argument: %s\n", db_arg);
            rc = 1;
            goto cleanup;
        }
    } 

    if (verbose >= 2)
        fprintf(stderr, "After arg parsing, mount_point: %s\n", mount_point ? mount_point : "(null)");

    if (config_file) {
        if (verbose >= 2)
            fprintf(stderr, "Loading config file: %s\n", config_file);
        if (parse_config(config_file, &db_arg, &mount_point, &format, &method, &output_file, &verbose) < 0) {
            fprintf(stderr, "Failed to parse config file: %s\n", config_file);
            rc = 1;
            goto cleanup;
        }
    }

    if (verbose >= 2)
        fprintf(stderr, "After config parsing, mount_point: %s\n", mount_point ? mount_point : "(null)");

    if (output_file) {
        if (verbose >= 3)
            fprintf(stderr, "Redirecting output to %s\n", output_file);
        if (!freopen(output_file, "w", stdout)) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to open output file %s: %s\n",
                    output_file, strerror(errno));
            fprintf(stderr, "Failed to open output file %s: %s\n",
                output_file, strerror(errno));
            rc = 1;
            goto cleanup;
        }
    }

    if (!search_term) {
        if (verbose >= 1)
            fprintf(stderr, "Missing search term\n");
        fprintf(stderr, "Missing search term (FID or path)\n");
        print_help(argv[0]);
        rc = 1;
        goto cleanup;
    }

    if (search_term[0] == '[' || strncmp(search_term, "0x", 2) == 0) {
        fid = strdup(search_term);
        if (!fid) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to allocate memory for fid\n");
            rc = 1;
            goto cleanup;
        }
        normalize_fid(fid);
        if (verbose >= 3)
            fprintf(stderr, "Treating search_term as FID: %s\n", fid);
    } else {
        normalized_path = strdup(search_term);
        if (!normalized_path) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to allocate memory for normalized_path\n");
            rc = 1;
            goto cleanup;
        }
        if (verbose >= 3)
            fprintf(stderr, "Treating search_term as path: %s\n", normalized_path);
    }

    int query_type = (fid != NULL);

    if (db_files_count == 0 && !db_glob && !db_template) {
        if (!db_path) db_path = ".";
        db_glob = "*.db";  // Always set this for directory scanning
        if (verbose >= 4)
            fprintf(stderr, "No db_arg provided, using default: path=%s, glob=%s\n", db_path, db_glob);
    }

    if (verbose >= 2)
        fprintf(stderr, "Calling collect_db_files, mount_point: %s\n", mount_point ? mount_point : "(null)");
    rc = collect_db_files(db_path, db_template, db_glob, db_files_list,
                          db_files_count, &db_files, &db_files_total);
    if (verbose >= 3)
        fprintf(stderr, "Set db_path: %s, db_template: %s, db_glob: %s\n",
                db_path ? db_path : "(null)", db_template ? db_template : "(null)", db_glob ? db_glob : "(null)");

    if (rc < 0) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to collect databases: %s\n", strerror(-rc));
        fprintf(stderr, "Error collecting databases: %s\n", strerror(-rc));
        rc = 1;
        goto cleanup;
    }

    if (db_files_total == 0) {
        if (verbose >= 1)
            fprintf(stderr, "No database files found\n");
        fprintf(stderr, "No database files found\n");
        rc = 1;
        goto cleanup;
    }

    if (verbose >= 2)
        fprintf(stderr, "Before querying, mount_point: %s\n", mount_point ? mount_point : "(null)");

    if (!fid) {
        if (verbose >= 2)
            fprintf(stderr, "Resolving path %s to FID, mount_point: %s\n",
                    normalized_path, mount_point ? mount_point : "(null)");
        char res_fid[MAX_FID_LEN];
        rc = resolve_path_to_fid(normalized_path, db_files, db_files_total,
                                 res_fid, sizeof(res_fid), mount_point);
        if (rc < 0) {
            fprintf(stderr, "Failed to resolve path to FID: %s\n", strerror(-rc));
            rc = 1;
            goto cleanup;
        }
        fid = strdup(res_fid);
        if (!fid) {
            if (verbose >= 1)
                fprintf(stderr, "Failed to allocate memory for fid\n");
            rc = 1;
            goto cleanup;
        }
        if (verbose >= 3)
            fprintf(stderr, "Path resolved to FID: %s, mount_point: %s\n",
                    fid, mount_point ? mount_point : "(null)");
    }

    struct history_list *list = calloc(1, sizeof(*list));
    if (!list) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to allocate history list\n");
        rc = 1;
        goto cleanup;
    }

    if (verbose >= 2)
        fprintf(stderr, "Querying with method: %s, mount_point: %s\n",
                method, mount_point ? mount_point : "(null)");
    if (strcmp(method, "loop") == 0)
        rc = query_loop(fid, db_files, db_files_total, list);
    else if (strcmp(method, "attach") == 0)
        rc = query_attach(fid, db_files, db_files_total, list);
    else {
        if (verbose >= 1)
            fprintf(stderr, "Invalid query method: %s\n", method);
        fprintf(stderr, "Invalid method: %s\n", method);
        rc = 1;
        goto cleanup_list;
    }
    if (rc < 0) {
        if (verbose >= 1)
            fprintf(stderr, "Query failed: %s\n", strerror(-rc));
        rc = 1;
        goto cleanup_list;
    }

    if (verbose >= 2)
        fprintf(stderr, "Sorting history list, mount_point: %s\n",
                mount_point ? mount_point : "(null)");
    sort_history_list(list);

    if (list->count == 0 && verbose >= 2)
        fprintf(stderr, "No records found for FID %s\n", fid);

    /* Create a copy of mount_point for output to avoid corruption */
    char *mount_point_copy = mount_point ? strdup(mount_point) : NULL;
    if (mount_point && !mount_point_copy) {
        if (verbose >= 1)
            fprintf(stderr, "Failed to duplicate mount_point for output\n");
        rc = 1;
        goto cleanup_list;
    }
    if (verbose >= 2)
        fprintf(stderr, "Before output, mount_point: %s, mount_point_copy: %s\n",
                mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");

    if (verbose >= 2)
        fprintf(stderr, "Outputting in format: %s\n", format);
    if (strcmp(format, "text") == 0) {
        if (verbose >= 3)
            fprintf(stderr, "Calling output_text, mount_point: %s, mount_point_copy: %s\n",
                    mount_point ? mount_point : "(null)", mount_point_copy ? mount_point_copy : "(null)");
		output_text(list, mount_point_copy, search_term, query_type);
        } else if (strcmp(format, "json") == 0) {
		output_json(list, mount_point_copy, search_term, query_type);
	} else if (strcmp(format, "yaml") == 0) {
		output_yaml(list, mount_point_copy, search_term, query_type);
	} else if (strcmp(format, "csv") == 0) {
		output_csv(list, mount_point_copy, search_term, query_type);
	} else if (strcmp(format, "fancy") == 0) {
		output_fancy(list, mount_point_copy, search_term, query_type);
	} else {
        if (verbose >= 1)
            fprintf(stderr, "Invalid output format: %s\n", format);
        fprintf(stderr, "Invalid format: %s\n", format);
        rc = 1;
    }

    free(mount_point_copy);

cleanup_list:
    if (verbose >= 2)
        fprintf(stderr, "Cleaning up history list\n");
    free_history_list(list);
cleanup:
    if (verbose >= 2)
        fprintf(stderr, "Cleaning up resources: %d db files, mount_point: %s\n",
                db_files_total, mount_point ? mount_point : "(null)");
    for (int i = 0; i < db_files_total; i++)
        free(db_files[i]);
    free(db_files);
    for (int i = 0; i < db_files_count; i++)
        free(db_files_list[i]);
    free(db_files_list);
    free(search_term);
    free(mount_point);
    free(format);
    free(method);
    free(output_file);
    free(config_file);
    free(db_arg);
    free(fid);
    free(normalized_path);

    if (verbose >= 1)
        fprintf(stderr, "Program exiting with status %d\n", rc);

    return rc;
}
